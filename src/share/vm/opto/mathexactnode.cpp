/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

#include "precompiled.hpp"
#include "memory/allocation.inline.hpp"
#include "opto/addnode.hpp"
#include "opto/machnode.hpp"
#include "opto/mathexactnode.hpp"
#include "opto/matcher.hpp"
#include "opto/subnode.hpp"

MathExactNode::MathExactNode(Node* ctrl, Node* n1, Node* n2) : MultiNode(3) {
  init_req(0, ctrl);
  init_req(1, n1);
  init_req(2, n2);
}

Node* AddExactINode::match(const ProjNode* proj, const Matcher* m) {
  uint ideal_reg = proj->ideal_reg();
  RegMask rm;
  if (proj->_con == result_proj_node) {
    rm = m->mathExactI_result_proj_mask();
  } else {
    assert(proj->_con == flags_proj_node, "must be result or flags");
    assert(ideal_reg == Op_RegFlags, "sanity");
    rm = m->mathExactI_flags_proj_mask();
  }
  return new (m->C) MachProjNode(this, proj->_con, rm, ideal_reg);
}

// If the MathExactNode won't overflow we have to replace the
// FlagsProjNode and ProjNode that is generated by the MathExactNode
Node* MathExactNode::no_overflow(PhaseGVN *phase, Node* new_result) {
  PhaseIterGVN *igvn = phase->is_IterGVN();
  if (igvn) {
    ProjNode* result = result_node();
    ProjNode* flags = flags_node();

    if (result != NULL) {
      igvn->replace_node(result, new_result);
    }

    if (flags != NULL) {
      BoolNode* bolnode = (BoolNode *) flags->unique_out();
      switch (bolnode->_test._test) {
        case BoolTest::overflow:
          // if the check is for overflow - never taken
          igvn->replace_node(bolnode, phase->intcon(0));
          break;
        case BoolTest::no_overflow:
          // if the check is for no overflow - always taken
          igvn->replace_node(bolnode, phase->intcon(1));
          break;
        default:
          fatal("Unexpected value of BoolTest");
          break;
      }
      flags->del_req(0);
    }
  }
  return new_result;
}

Node *AddExactINode::Ideal(PhaseGVN *phase, bool can_reshape) {
  Node *arg1 = in(1);
  Node *arg2 = in(2);

  const Type* type1 = phase->type(arg1);
  const Type* type2 = phase->type(arg2);

  if (type1 != Type::TOP && type1->singleton() &&
      type2 != Type::TOP && type2->singleton()) {
    jint val1 = arg1->get_int();
    jint val2 = arg2->get_int();
    jint result = val1 + val2;
    // Hacker's Delight 2-12 Overflow if both arguments have the opposite sign of the result
    if ( (((val1 ^ result) & (val2 ^ result)) >= 0)) {
      Node* con_result = ConINode::make(phase->C, result);
      return no_overflow(phase, con_result);
    }
    return NULL;
  }

  if (type1 == TypeInt::ZERO) { // (Add 0 x) == x
    Node* add_result = new (phase->C) AddINode(arg1, arg2);
    return no_overflow(phase, add_result);
  }

  if (type2 == TypeInt::ZERO) { // (Add x 0) == x
    Node* add_result = new (phase->C) AddINode(arg1, arg2);
    return no_overflow(phase, add_result);
  }

  if (type2->singleton()) {
    return NULL; // no change - keep constant on the right
  }

  if (type1->singleton()) {
    // Make it x + Constant - move constant to the right
    swap_edges(1, 2);
    return this;
  }

  if (arg2->is_Load()) {
    return NULL; // no change - keep load on the right
  }

  if (arg1->is_Load()) {
    // Make it x + Load - move load to the right
    swap_edges(1, 2);
    return this;
  }

  if (arg1->_idx > arg2->_idx) {
    // Sort the edges
    swap_edges(1, 2);
    return this;
  }

  return NULL;
}

