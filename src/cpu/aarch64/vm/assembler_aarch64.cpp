/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights
 * reserved.  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE
 * HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

#undef TARGET_ARCH_x86
#define TARGET_ARCH_AARCH64
#define CPU_X86_VM_REGISTER_X86_HPP

#include <stdio.h>
#include <sys/types.h>

#include "precompiled.hpp"
#include "assembler_aarch64.inline.hpp"
#include "asm/assembler.hpp"
#include "assembler_aarch64.hpp"

#include "compiler/disassembler.hpp"
#include "memory/resourceArea.hpp"
#include "runtime/interfaceSupport.hpp"
#include "runtime/sharedRuntime.hpp"

// #include "gc_interface/collectedHeap.inline.hpp"
// #include "interpreter/interpreter.hpp"
// #include "memory/cardTableModRefBS.hpp"
// #include "prims/methodHandles.hpp"
// #include "runtime/biasedLocking.hpp"
// #include "runtime/interfaceSupport.hpp"
// #include "runtime/objectMonitor.hpp"
// #include "runtime/os.hpp"
// #include "runtime/sharedRuntime.hpp"
// #include "runtime/stubRoutines.hpp"
// #ifndef SERIALGC
// #include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
// #include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
// #include "gc_implementation/g1/heapRegion.hpp"
// #endif


extern "C" void entry(CodeBuffer *cb);

#define __ _masm.

void entry(CodeBuffer *cb) {
  Assembler _masm(cb);
  address entry = __ pc();

  // Smoke test for assembler

#if ASSERT
// BEGIN  Generated code -- do not edit
// Generated by aarch64-asmtest.py
    Label back, forth;
    __ bind(back);

// ArithOp
    __ add(r15, r15, r11, Assembler::ASR, 28);         //	add	x15, x15, x11, ASR #28
    __ sub(r10, r8, r20, Assembler::LSR, 63);          //	sub	x10, x8, x20, LSR #63
    __ adds(r28, r9, r9, Assembler::LSR, 18);          //	adds	x28, x9, x9, LSR #18
    __ subs(r17, r25, r30, Assembler::LSR, 0);         //	subs	x17, x25, x30, LSR #0
    __ addw(r3, r23, r5, Assembler::ASR, 18);          //	add	w3, w23, w5, ASR #18
    __ subw(r10, r20, r19, Assembler::LSR, 16);        //	sub	w10, w20, w19, LSR #16
    __ addsw(r13, r11, r3, Assembler::ASR, 24);        //	adds	w13, w11, w3, ASR #24
    __ subsw(r18, r22, r26, Assembler::LSR, 10);       //	subs	w18, w22, w26, LSR #10
    __ andr(r24, r17, r29, Assembler::LSL, 17);        //	and	x24, x17, x29, LSL #17
    __ orr(r17, r29, r21, Assembler::LSR, 39);         //	orr	x17, x29, x21, LSR #39
    __ eor(r4, r21, r18, Assembler::LSR, 2);           //	eor	x4, x21, x18, LSR #2
    __ ands(r27, r2, r21, Assembler::ASR, 23);         //	ands	x27, x2, x21, ASR #23
    __ andw(r4, r1, r9, Assembler::ASR, 13);           //	and	w4, w1, w9, ASR #13
    __ orrw(r7, r5, r18, Assembler::LSR, 19);          //	orr	w7, w5, w18, LSR #19
    __ eorw(r30, r9, r18, Assembler::LSR, 21);         //	eor	w30, w9, w18, LSR #21
    __ andsw(r28, r12, r9, Assembler::LSL, 2);         //	ands	w28, w12, w9, LSL #2
    __ bic(r8, r7, r26, Assembler::LSL, 22);           //	bic	x8, x7, x26, LSL #22
    __ orn(r19, r19, r17, Assembler::LSR, 40);         //	orn	x19, x19, x17, LSR #40
    __ eon(r13, r6, r9, Assembler::LSL, 1);            //	eon	x13, x6, x9, LSL #1
    __ bics(r13, r23, r13, Assembler::ASR, 46);        //	bics	x13, x23, x13, ASR #46
    __ bicw(r13, r5, r15, Assembler::LSL, 17);         //	bic	w13, w5, w15, LSL #17
    __ ornw(r17, r9, r14, Assembler::LSL, 16);         //	orn	w17, w9, w14, LSL #16
    __ eonw(r7, r4, r28, Assembler::ASR, 17);          //	eon	w7, w4, w28, ASR #17
    __ bicsw(r6, r26, r1, Assembler::LSL, 18);         //	bics	w6, w26, w1, LSL #18

// AddSubImmOp
    __ addw(r7, r8, 674u);                             //	add	w7, w8, #674
    __ addsw(r24, r5, 382u);                           //	adds	w24, w5, #382
    __ subw(r19, r24, 604u);                           //	sub	w19, w24, #604
    __ subsw(r24, r16, 773u);                          //	subs	w24, w16, #773
    __ add(r24, r3, 600u);                             //	add	x24, x3, #600
    __ adds(r23, r21, 911u);                           //	adds	x23, x21, #911
    __ sub(r9, r5, 878u);                              //	sub	x9, x5, #878
    __ subs(r4, r7, 942u);                             //	subs	x4, x7, #942

// LogicalImmOp
    __ andw(r12, r29, 1048576ul);                      //	and	w12, w29, #0x100000
    __ orrw(r0, r9, 3233857728ul);                     //	orr	w0, w9, #0xc0c0c0c0
    __ eorw(r12, r6, 496ul);                           //	eor	w12, w6, #0x1f0
    __ andsw(r4, r5, 4278206463ul);                    //	ands	w4, w5, #0xff003fff
    __ andr(r12, r2, 18446744056529698815ul);          //	and	x12, x2, #0xfffffffc00003fff
    __ orr(r25, r29, 16429131440647569407ul);          //	orr	x25, x29, #0xe3ffffffffffffff
    __ eor(r29, r14, 17296056810822168583ul);          //	eor	x29, x14, #0xf007f007f007f007
    __ ands(r17, r7, 562675075514368ul);               //	ands	x17, x7, #0x1ffc000000000

// AbsOp
    __ b(__ pc());                                     //	b	.
    __ b(back);                                        //	b	back
    __ b(forth);                                       //	b	forth
    __ bl(__ pc());                                    //	bl	.
    __ bl(back);                                       //	bl	back
    __ bl(forth);                                      //	bl	forth

// RegAndAbsOp
    __ cbzw(r6, __ pc());                              //	cbz	w6, .
    __ cbzw(r6, back);                                 //	cbz	w6, back
    __ cbzw(r6, forth);                                //	cbz	w6, forth
    __ cbnzw(r23, __ pc());                            //	cbnz	w23, .
    __ cbnzw(r23, back);                               //	cbnz	w23, back
    __ cbnzw(r23, forth);                              //	cbnz	w23, forth
    __ cbz(r3, __ pc());                               //	cbz	x3, .
    __ cbz(r3, back);                                  //	cbz	x3, back
    __ cbz(r3, forth);                                 //	cbz	x3, forth
    __ cbnz(r1, __ pc());                              //	cbnz	x1, .
    __ cbnz(r1, back);                                 //	cbnz	x1, back
    __ cbnz(r1, forth);                                //	cbnz	x1, forth
    __ adr(r9, __ pc());                               //	adr	x9, .
    __ adr(r9, back);                                  //	adr	x9, back
    __ adr(r9, forth);                                 //	adr	x9, forth
    __ adrp(r14, __ pc());                             //	adrp	x14, .

// RegImmAbsOp
    __ tbz(r9, 2, __ pc());                            //	tbz	x9, #2, .
    __ tbz(r9, 2, back);                               //	tbz	x9, #2, back
    __ tbz(r9, 2, forth);                              //	tbz	x9, #2, forth
    __ tbnz(r1, 10, __ pc());                          //	tbnz	x1, #10, .
    __ tbnz(r1, 10, back);                             //	tbnz	x1, #10, back
    __ tbnz(r1, 10, forth);                            //	tbnz	x1, #10, forth

// MoveWideImmOp
    __ movnw(r1, 20526, 0);                            //	movn	w1, #20526, lsl 0
    __ movzw(r8, 7603, 0);                             //	movz	w8, #7603, lsl 0
    __ movkw(r3, 28605, 16);                           //	movk	w3, #28605, lsl 16
    __ movn(r12, 29379, 48);                           //	movn	x12, #29379, lsl 48
    __ movz(r18, 26556, 16);                           //	movz	x18, #26556, lsl 16
    __ movk(r30, 17366, 48);                           //	movk	x30, #17366, lsl 48

// BitfieldOp
    __ sbfm(r12, r30, 24, 3);                          //	sbfm	x12, x30, #24, #3
    __ bfmw(r18, r28, 17, 8);                          //	bfm	w18, w28, #17, #8
    __ ubfmw(r14, r25, 3, 2);                          //	ubfm	w14, w25, #3, #2
    __ sbfm(r6, r16, 2, 22);                           //	sbfm	x6, x16, #2, #22
    __ bfm(r11, r14, 6, 8);                            //	bfm	x11, x14, #6, #8
    __ ubfm(r18, r29, 14, 13);                         //	ubfm	x18, x29, #14, #13

// ExtractOp
    __ extrw(r0, r27, r19, 13);                        //	extr	w0, w27, w19, #13
    __ extr(r4, r7, r12, 17);                          //	extr	x4, x7, x12, #17

// CondBranchOp
    __ br(Assembler::EQ, __ pc());                     //	b.EQ	.
    __ br(Assembler::EQ, back);                        //	b.EQ	back
    __ br(Assembler::EQ, forth);                       //	b.EQ	forth
    __ br(Assembler::NE, __ pc());                     //	b.NE	.
    __ br(Assembler::NE, back);                        //	b.NE	back
    __ br(Assembler::NE, forth);                       //	b.NE	forth
    __ br(Assembler::HS, __ pc());                     //	b.HS	.
    __ br(Assembler::HS, back);                        //	b.HS	back
    __ br(Assembler::HS, forth);                       //	b.HS	forth
    __ br(Assembler::CS, __ pc());                     //	b.CS	.
    __ br(Assembler::CS, back);                        //	b.CS	back
    __ br(Assembler::CS, forth);                       //	b.CS	forth
    __ br(Assembler::LO, __ pc());                     //	b.LO	.
    __ br(Assembler::LO, back);                        //	b.LO	back
    __ br(Assembler::LO, forth);                       //	b.LO	forth
    __ br(Assembler::CC, __ pc());                     //	b.CC	.
    __ br(Assembler::CC, back);                        //	b.CC	back
    __ br(Assembler::CC, forth);                       //	b.CC	forth
    __ br(Assembler::MI, __ pc());                     //	b.MI	.
    __ br(Assembler::MI, back);                        //	b.MI	back
    __ br(Assembler::MI, forth);                       //	b.MI	forth
    __ br(Assembler::PL, __ pc());                     //	b.PL	.
    __ br(Assembler::PL, back);                        //	b.PL	back
    __ br(Assembler::PL, forth);                       //	b.PL	forth
    __ br(Assembler::VS, __ pc());                     //	b.VS	.
    __ br(Assembler::VS, back);                        //	b.VS	back
    __ br(Assembler::VS, forth);                       //	b.VS	forth
    __ br(Assembler::VC, __ pc());                     //	b.VC	.
    __ br(Assembler::VC, back);                        //	b.VC	back
    __ br(Assembler::VC, forth);                       //	b.VC	forth
    __ br(Assembler::HI, __ pc());                     //	b.HI	.
    __ br(Assembler::HI, back);                        //	b.HI	back
    __ br(Assembler::HI, forth);                       //	b.HI	forth
    __ br(Assembler::LS, __ pc());                     //	b.LS	.
    __ br(Assembler::LS, back);                        //	b.LS	back
    __ br(Assembler::LS, forth);                       //	b.LS	forth
    __ br(Assembler::GE, __ pc());                     //	b.GE	.
    __ br(Assembler::GE, back);                        //	b.GE	back
    __ br(Assembler::GE, forth);                       //	b.GE	forth
    __ br(Assembler::LT, __ pc());                     //	b.LT	.
    __ br(Assembler::LT, back);                        //	b.LT	back
    __ br(Assembler::LT, forth);                       //	b.LT	forth
    __ br(Assembler::GT, __ pc());                     //	b.GT	.
    __ br(Assembler::GT, back);                        //	b.GT	back
    __ br(Assembler::GT, forth);                       //	b.GT	forth
    __ br(Assembler::LE, __ pc());                     //	b.LE	.
    __ br(Assembler::LE, back);                        //	b.LE	back
    __ br(Assembler::LE, forth);                       //	b.LE	forth
    __ br(Assembler::AL, __ pc());                     //	b.AL	.
    __ br(Assembler::AL, back);                        //	b.AL	back
    __ br(Assembler::AL, forth);                       //	b.AL	forth
    __ br(Assembler::NV, __ pc());                     //	b.NV	.
    __ br(Assembler::NV, back);                        //	b.NV	back
    __ br(Assembler::NV, forth);                       //	b.NV	forth

// ImmOp
    __ svc(31435);                                     //	svc	#31435
    __ hvc(27456);                                     //	hvc	#27456
    __ smc(22449);                                     //	smc	#22449
    __ brk(6192);                                      //	brk	#6192
    __ hlt(7811);                                      //	hlt	#7811

// Op
    __ nop();                                          //	nop	
    __ eret();                                         //	eret	
    __ drps();                                         //	drps	
    __ isb();                                          //	isb	

// SystemOp
    __ dsb(Assembler::OSHLD);                          //	dsb	OSHLD
    __ dmb(Assembler::OSHST);                          //	dmb	OSHST

// OneRegOp
    __ br(r8);                                         //	br	x8
    __ blr(r18);                                       //	blr	x18

// LoadStoreExclusiveOp
    __ stxr(r12, r14, r15);                            //	stxr	w12, x14, [x15]
    __ stlxr(r30, r14, r8);                            //	stlxr	w30, x14, [x8]
    __ ldxr(r2, r16);                                  //	ldxr	x2, [x16]
    __ ldaxr(r15, r13);                                //	ldaxr	x15, [x13]
    __ stlr(r7, r13);                                  //	stlr	x7, [x13]
    __ ldar(r30, r16);                                 //	ldar	x30, [x16]

// LoadStoreExclusiveOp
    __ stxrw(r6, r10, r4);                             //	stxr	w6, w10, [x4]
    __ stlxrw(r7, r17, r9);                            //	stlxr	w7, w17, [x9]
    __ ldxrw(r5, r3);                                  //	ldxr	w5, [x3]
    __ ldaxrw(r6, r25);                                //	ldaxr	w6, [x25]
    __ stlrw(r6, r30);                                 //	stlr	w6, [x30]
    __ ldarw(r0, r13);                                 //	ldar	w0, [x13]

// LoadStoreExclusiveOp
    __ stxrh(r20, r26, r24);                           //	stxrh	w20, w26, [x24]
    __ stlxrh(r24, r24, r18);                          //	stlxrh	w24, w24, [x18]
    __ ldxrh(r19, r30);                                //	ldxrh	w19, [x30]
    __ ldaxrh(r26, r3);                                //	ldaxrh	w26, [x3]
    __ stlrh(r12, r8);                                 //	stlrh	w12, [x8]
    __ ldarh(r11, r30);                                //	ldarh	w11, [x30]

// LoadStoreExclusiveOp
    __ stxrb(r1, r4, r25);                             //	stxrb	w1, w4, [x25]
    __ stlxrb(r9, r16, r24);                           //	stlxrb	w9, w16, [x24]
    __ ldxrb(r4, r3);                                  //	ldxrb	w4, [x3]
    __ ldaxrb(r9, r5);                                 //	ldaxrb	w9, [x5]
    __ stlrb(r5, r20);                                 //	stlrb	w5, [x20]
    __ ldarb(r17, r21);                                //	ldarb	w17, [x21]

// LoadStoreExclusiveOp
    __ ldxp(r8, r13, r14);                             //	ldxp	x8, x13, [x14]
    __ ldaxp(r28, r22, r14);                           //	ldaxp	x28, x22, [x14]
    __ stxp(r17, r10, r22, r20);                       //	stxp	w17, x10, x22, [x20]
    __ stlxp(r28, r1, r29, r26);                       //	stlxp	w28, x1, x29, [x26]

// LoadStoreExclusiveOp
    __ ldxpw(r0, r4, r6);                              //	ldxp	w0, w4, [x6]
    __ ldaxpw(r17, r7, r22);                           //	ldaxp	w17, w7, [x22]
    __ stxpw(r2, r23, r1, r19);                        //	stxp	w2, w23, w1, [x19]
    __ stlxpw(r15, r14, r9, r3);                       //	stlxp	w15, w14, w9, [x3]

// base_plus_unscaled_offset 
// LoadStoreOp
    __ str(r20, Address(r18, -29));                    //	str	x20, [x18, -29]
    __ strw(r30, Address(r26, 32));                    //	str	w30, [x26, 32]
    __ strb(r5, Address(r21, -30));                    //	strb	w5, [x21, -30]
    __ strh(r18, Address(r6, -14));                    //	strh	w18, [x6, -14]
    __ ldr(r11, Address(r22, -13));                    //	ldr	x11, [x22, -13]
    __ ldrw(r14, Address(r2, -119));                   //	ldr	w14, [x2, -119]
    __ ldrb(r25, Address(r16, -18));                   //	ldrb	w25, [x16, -18]
    __ ldrh(r0, Address(r18, -39));                    //	ldrh	w0, [x18, -39]
    __ ldrsb(r1, Address(r19, -12));                   //	ldrsb	x1, [x19, -12]
    __ ldrsh(r25, Address(r10, -36));                  //	ldrsh	x25, [x10, -36]
    __ ldrshw(r1, Address(r20, -28));                  //	ldrsh	w1, [x20, -28]
    __ ldrsw(r9, Address(r8, 11));                     //	ldrsw	x9, [x8, 11]
    __ ldrd(v4, Address(r7, -229));                    //	ldr	d4, [x7, -229]
    __ ldrs(v14, Address(r24, 1));                     //	ldr	s14, [x24, 1]
    __ strd(v1, Address(r1, 87));                      //	str	d1, [x1, 87]
    __ strs(v18, Address(r19, 8));                     //	str	s18, [x19, 8]

// pre 
// LoadStoreOp
    __ str(r12, Address(__ pre(r24, -189)));           //	str	x12, [x24, -189]!
    __ strw(r24, Address(__ pre(r20, -120)));          //	str	w24, [x20, -120]!
    __ strb(r28, Address(__ pre(r5, -15)));            //	strb	w28, [x5, -15]!
    __ strh(r3, Address(__ pre(r9, -12)));             //	strh	w3, [x9, -12]!
    __ ldr(r26, Address(__ pre(r9, -58)));             //	ldr	x26, [x9, -58]!
    __ ldrw(r13, Address(__ pre(r10, -31)));           //	ldr	w13, [x10, -31]!
    __ ldrb(r19, Address(__ pre(r29, 11)));            //	ldrb	w19, [x29, 11]!
    __ ldrh(r27, Address(__ pre(r29, -33)));           //	ldrh	w27, [x29, -33]!
    __ ldrsb(r22, Address(__ pre(r4, -13)));           //	ldrsb	x22, [x4, -13]!
    __ ldrsh(r12, Address(__ pre(r11, -63)));          //	ldrsh	x12, [x11, -63]!
    __ ldrshw(r29, Address(__ pre(r26, -6)));          //	ldrsh	w29, [x26, -6]!
    __ ldrsw(r21, Address(__ pre(r22, -36)));          //	ldrsw	x21, [x22, -36]!
    __ ldrd(v30, Address(__ pre(r26, -41)));           //	ldr	d30, [x26, -41]!
    __ ldrs(v17, Address(__ pre(r15, 8)));             //	ldr	s17, [x15, 8]!
    __ strd(v1, Address(__ pre(r6, -206)));            //	str	d1, [x6, -206]!
    __ strs(v2, Address(__ pre(r5, -111)));            //	str	s2, [x5, -111]!

// post 
// LoadStoreOp
    __ str(r13, Address(__ post(r26, 15)));            //	str	x13, [x26], 15
    __ strw(r24, Address(__ post(r15, 16)));           //	str	w24, [x15], 16
    __ strb(r8, Address(__ post(r12, 0)));             //	strb	w8, [x12], 0
    __ strh(r29, Address(__ post(r14, -58)));          //	strh	w29, [x14], -58
    __ ldr(r16, Address(__ post(r26, -182)));          //	ldr	x16, [x26], -182
    __ ldrw(r2, Address(__ post(r0, -86)));            //	ldr	w2, [x0], -86
    __ ldrb(r3, Address(__ post(r8, -27)));            //	ldrb	w3, [x8], -27
    __ ldrh(r7, Address(__ post(r30, -18)));           //	ldrh	w7, [x30], -18
    __ ldrsb(r30, Address(__ post(r8, 5)));            //	ldrsb	x30, [x8], 5
    __ ldrsh(r1, Address(__ post(r11, -11)));          //	ldrsh	x1, [x11], -11
    __ ldrshw(r19, Address(__ post(r15, 30)));         //	ldrsh	w19, [x15], 30
    __ ldrsw(r9, Address(__ post(r6, 51)));            //	ldrsw	x9, [x6], 51
    __ ldrd(v28, Address(__ post(r14, -111)));         //	ldr	d28, [x14], -111
    __ ldrs(v25, Address(__ post(r14, 35)));           //	ldr	s25, [x14], 35
    __ strd(v10, Address(__ post(r0, 31)));            //	str	d10, [x0], 31
    __ strs(v24, Address(__ post(r7, -121)));          //	str	s24, [x7], -121

// base_plus_reg 
// LoadStoreOp
    __ str(r30, Address(r21, r22, Address::sxtx(0)));  //	str	x30, [x21, x22, sxtx #0]
    __ strw(r3, Address(r10, r3, Address::uxtw(2)));   //	str	w3, [x10, w3, uxtw #2]
    __ strb(r12, Address(r29, r30, Address::uxtw(0))); //	strb	w12, [x29, w30, uxtw #0]
    __ strh(r6, Address(r18, r18, Address::sxtx(0)));  //	strh	w6, [x18, x18, sxtx #0]
    __ ldr(r23, Address(r28, r18, Address::lsl(0)));   //	ldr	x23, [x28, x18, lsl #0]
    __ ldrw(r12, Address(r7, r17, Address::lsl(2)));   //	ldr	w12, [x7, x17, lsl #2]
    __ ldrb(r28, Address(r2, r24, Address::uxtw(0)));  //	ldrb	w28, [x2, w24, uxtw #0]
    __ ldrh(r2, Address(r30, r27, Address::lsl(1)));   //	ldrh	w2, [x30, x27, lsl #1]
    __ ldrsb(r25, Address(r16, r0, Address::sxtw(0))); //	ldrsb	x25, [x16, w0, sxtw #0]
    __ ldrsh(r17, Address(r23, r30, Address::sxtx(1))); //	ldrsh	x17, [x23, x30, sxtx #1]
    __ ldrshw(r27, Address(r29, r20, Address::uxtw(0))); //	ldrsh	w27, [x29, w20, uxtw #0]
    __ ldrsw(r0, Address(r26, r27, Address::sxtx(2))); //	ldrsw	x0, [x26, x27, sxtx #2]
    __ ldrd(v16, Address(r4, r27, Address::lsl(0)));   //	ldr	d16, [x4, x27, lsl #0]
    __ ldrs(v26, Address(r30, r19, Address::sxtw(2))); //	ldr	s26, [x30, w19, sxtw #2]
    __ strd(v2, Address(r5, r17, Address::sxtx(3)));   //	str	d2, [x5, x17, sxtx #3]
    __ strs(v28, Address(r29, r13, Address::lsl(0)));  //	str	s28, [x29, x13, lsl #0]

// base_plus_scaled_offset 
// LoadStoreOp
    __ str(r1, Address(r29, 13328));                   //	str	x1, [x29, 13328]
    __ strw(r30, Address(r25, 6472));                  //	str	w30, [x25, 6472]
    __ strb(r24, Address(r15, 1848));                  //	strb	w24, [x15, 1848]
    __ strh(r2, Address(r23, 3540));                   //	strh	w2, [x23, 3540]
    __ ldr(r18, Address(r20, 12720));                  //	ldr	x18, [x20, 12720]
    __ ldrw(r11, Address(r12, 7652));                  //	ldr	w11, [x12, 7652]
    __ ldrb(r19, Address(r24, 1626));                  //	ldrb	w19, [x24, 1626]
    __ ldrh(r7, Address(r29, 3430));                   //	ldrh	w7, [x29, 3430]
    __ ldrsb(r26, Address(r17, 1945));                 //	ldrsb	x26, [x17, 1945]
    __ ldrsh(r14, Address(r23, 3116));                 //	ldrsh	x14, [x23, 3116]
    __ ldrshw(r6, Address(r11, 3616));                 //	ldrsh	w6, [x11, 3616]
    __ ldrsw(r13, Address(r5, 7292));                  //	ldrsw	x13, [x5, 7292]
    __ ldrd(v6, Address(r12, 15112));                  //	ldr	d6, [x12, 15112]
    __ ldrs(v29, Address(r4, 7908));                   //	ldr	s29, [x4, 7908]
    __ strd(v27, Address(r4, 13696));                  //	str	d27, [x4, 13696]
    __ strs(v16, Address(r14, 7440));                  //	str	s16, [x14, 7440]

// pcrel 
// LoadStoreOp
    __ ldr(r26, __ pc());                              //	ldr	x26, .
    __ ldrw(r16, back);                                //	ldr	w16, back

// LoadStoreOp
    __ prfm(Address(r8, -213));                        //	prfm	PLDL1KEEP, [x8, -213]

// LoadStoreOp
    __ prfm(back);                                     //	prfm	PLDL1KEEP, back

// LoadStoreOp
    __ prfm(Address(r24, r8, Address::lsl(3)));        //	prfm	PLDL1KEEP, [x24, x8, lsl #3]

// LoadStoreOp
    __ prfm(Address(r20, 13728));                      //	prfm	PLDL1KEEP, [x20, 13728]

// AddSubCarryOp
    __ adcw(r0, r16, r1);                              //	adc	w0, w16, w1
    __ adcsw(r3, r14, r20);                            //	adcs	w3, w14, w20
    __ sbcw(r21, r10, r6);                             //	sbc	w21, w10, w6
    __ sbcsw(r11, r27, r21);                           //	sbcs	w11, w27, w21
    __ adc(r8, r7, r24);                               //	adc	x8, x7, x24
    __ adcs(r17, r7, r6);                              //	adcs	x17, x7, x6
    __ sbc(r27, r6, r22);                              //	sbc	x27, x6, x22
    __ sbcs(r28, r18, r9);                             //	sbcs	x28, x18, x9

// AddSubExtendedOp
    __ addw(r21, r4, r4, ext::uxtw, 3);                //	add	w21, w4, w4, uxtw #3
    __ addsw(r8, r14, r11, ext::sxtw, 1);              //	adds	w8, w14, w11, sxtw #1
    __ sub(r24, r13, r5, ext::uxtx, 1);                //	sub	x24, x13, x5, uxtx #1
    __ subsw(r12, r19, r29, ext::sxtb, 3);             //	subs	w12, w19, w29, sxtb #3
    __ add(r7, r15, r17, ext::uxth, 2);                //	add	x7, x15, x17, uxth #2
    __ adds(r22, r6, r21, ext::uxtw, 2);               //	adds	x22, x6, x21, uxtw #2
    __ sub(r28, r28, r16, ext::sxtw, 4);               //	sub	x28, x28, x16, sxtw #4
    __ subs(r11, r12, r26, ext::sxtx, 1);              //	subs	x11, x12, x26, sxtx #1

// ConditionalCompareOp
    __ ccmnw(r4, r15, 7u, Assembler::PL);              //	ccmn	w4, w15, #7, PL
    __ ccmpw(r1, r12, 14u, Assembler::GT);             //	ccmp	w1, w12, #14, GT
    __ ccmn(r19, r26, 2u, Assembler::HI);              //	ccmn	x19, x26, #2, HI
    __ ccmp(r2, r3, 7u, Assembler::LT);                //	ccmp	x2, x3, #7, LT

// ConditionalCompareImmedOp
    __ ccmnw(r16, 18, 8, Assembler::LE);               //	ccmn	w16, #18, #8, LE
    __ ccmpw(r15, 14, 12, Assembler::GE);              //	ccmp	w15, #14, #12, GE
    __ ccmn(r19, 15, 9, Assembler::GT);                //	ccmn	x19, #15, #9, GT
    __ ccmp(r25, 23, 6, Assembler::GT);                //	ccmp	x25, #23, #6, GT

// ConditionalSelectOp
    __ cselw(r0, r13, r24, Assembler::LO);             //	csel	w0, w13, w24, LO
    __ csincw(r17, r23, r19, Assembler::CS);           //	csinc	w17, w23, w19, CS
    __ csinvw(r16, r26, r15, Assembler::HS);           //	csinv	w16, w26, w15, HS
    __ csnegw(r7, r3, r17, Assembler::VS);             //	csneg	w7, w3, w17, VS
    __ csel(r29, r14, r10, Assembler::LE);             //	csel	x29, x14, x10, LE
    __ csinc(r3, r27, r20, Assembler::HS);             //	csinc	x3, x27, x20, HS
    __ csinv(r3, r30, r19, Assembler::NE);             //	csinv	x3, x30, x19, NE
    __ csneg(r9, r0, r26, Assembler::LS);              //	csneg	x9, x0, x26, LS

// TwoRegOp
    __ rbitw(r17, r21);                                //	rbit	w17, w21
    __ rev16w(r14, r10);                               //	rev16	w14, w10
    __ revw(r17, r28);                                 //	rev	w17, w28
    __ clzw(r15, r14);                                 //	clz	w15, w14
    __ clsw(r26, r14);                                 //	cls	w26, w14
    __ rbit(r13, r15);                                 //	rbit	x13, x15
    __ rev16(r4, r21);                                 //	rev16	x4, x21
    __ rev32(r26, r17);                                //	rev32	x26, x17
    __ rev(r11, r19);                                  //	rev	x11, x19
    __ clz(r24, r14);                                  //	clz	x24, x14
    __ cls(r19, r16);                                  //	cls	x19, x16

// ThreeRegOp
    __ udivw(r27, r5, r24);                            //	udiv	w27, w5, w24
    __ sdivw(r17, r29, r3);                            //	sdiv	w17, w29, w3
    __ lslvw(r0, r29, r21);                            //	lslv	w0, w29, w21
    __ lsrvw(r19, r23, r21);                           //	lsrv	w19, w23, w21
    __ asrvw(r28, r18, r7);                            //	asrv	w28, w18, w7
    __ rorvw(r8, r6, r26);                             //	rorv	w8, w6, w26
    __ udiv(r4, r24, r19);                             //	udiv	x4, x24, x19
    __ sdiv(r10, r22, r8);                             //	sdiv	x10, x22, x8
    __ lslv(r8, r19, r25);                             //	lslv	x8, x19, x25
    __ lsrv(r16, r1, r26);                             //	lsrv	x16, x1, x26
    __ asrv(r14, r3, r26);                             //	asrv	x14, x3, x26
    __ rorv(r15, r3, r19);                             //	rorv	x15, x3, x19

// FourRegMulOp
    __ maddw(r22, r14, r30, r27);                      //	madd	w22, w14, w30, w27
    __ msubw(r6, r20, r9, r7);                         //	msub	w6, w20, w9, w7
    __ madd(r16, r3, r5, r5);                          //	madd	x16, x3, x5, x5
    __ msub(r22, r16, r9, r0);                         //	msub	x22, x16, x9, x0
    __ smaddl(r11, r17, r7, r22);                      //	smaddl	x11, w17, w7, x22
    __ smsubl(r26, r26, r24, r25);                     //	smsubl	x26, w26, w24, x25
    __ umaddl(r21, r14, r19, r26);                     //	umaddl	x21, w14, w19, x26
    __ umsubl(r0, r26, r7, r7);                        //	umsubl	x0, w26, w7, x7

// ThreeRegFloatOp
    __ fmuls(v1, v21, v14);                            //	fmul	s1, s21, s14
    __ fdivs(v25, v20, v21);                           //	fdiv	s25, s20, s21
    __ fadds(v13, v16, v27);                           //	fadd	s13, s16, s27
    __ fsubs(v9, v20, v18);                            //	fsub	s9, s20, s18
    __ fmuls(v14, v2, v30);                            //	fmul	s14, s2, s30
    __ fmuld(v4, v15, v24);                            //	fmul	d4, d15, d24
    __ fdivd(v28, v11, v26);                           //	fdiv	d28, d11, d26
    __ faddd(v26, v0, v0);                             //	fadd	d26, d0, d0
    __ fsubd(v22, v9, v20);                            //	fsub	d22, d9, d20
    __ fmuld(v4, v29, v17);                            //	fmul	d4, d29, d17

// FourRegFloatOp
    __ fmadds(v29, v22, v28, v12);                     //	fmadd	s29, s22, s28, s12
    __ fmsubs(v6, v25, v29, v18);                      //	fmsub	s6, s25, s29, s18
    __ fnmadds(v1, v30, v23, v25);                     //	fnmadd	s1, s30, s23, s25
    __ fnmadds(v30, v6, v3, v4);                       //	fnmadd	s30, s6, s3, s4
    __ fmaddd(v22, v18, v5, v15);                      //	fmadd	d22, d18, d5, d15
    __ fmsubd(v14, v26, v29, v2);                      //	fmsub	d14, d26, d29, d2
    __ fnmaddd(v16, v10, v17, v15);                    //	fnmadd	d16, d10, d17, d15
    __ fnmaddd(v18, v28, v18, v16);                    //	fnmadd	d18, d28, d18, d16

// TwoRegFloatOp
    __ fmovs(v25, v11);                                //	fmov	s25, s11
    __ fabss(v12, v9);                                 //	fabs	s12, s9
    __ fnegs(v28, v13);                                //	fneg	s28, s13
    __ fsqrts(v9, v0);                                 //	fsqrt	s9, s0
    __ fcvts(v0, v2);                                  //	fcvt	d0, s2
    __ fmovd(v5, v13);                                 //	fmov	d5, d13
    __ fabsd(v0, v15);                                 //	fabs	d0, d15
    __ fnegd(v10, v22);                                //	fneg	d10, d22
    __ fsqrtd(v16, v6);                                //	fsqrt	d16, d6
    __ fcvtd(v19, v9);                                 //	fcvt	s19, d9

// FloatConvertOp
    __ fcvtzsw(r15, v25);                              //	fcvtzs	w15, s25
    __ fcvtzs(r14, v7);                                //	fcvtzs	x14, s7
    __ fcvtzdw(r17, v23);                              //	fcvtzs	w17, d23
    __ fcvtzd(r11, v15);                               //	fcvtzs	x11, d15
    __ scvtfws(v6, r6);                                //	scvtf	s6, w6
    __ scvtfs(v3, r30);                                //	scvtf	s3, x30
    __ scvtfwd(v6, r18);                               //	scvtf	d6, w18
    __ scvtfd(v4, r19);                                //	scvtf	d4, x19
    __ fmovs(r28, v17);                                //	fmov	w28, s17
    __ fmovd(r11, v18);                                //	fmov	x11, d18
    __ fmovs(v25, r18);                                //	fmov	s25, w18
    __ fmovd(v19, r24);                                //	fmov	d19, x24

// TwoRegFloatOp
    __ fcmps(v17, v24);                                //	fcmp	s17, s24
    __ fcmpd(v0, v6);                                  //	fcmp	d0, d6
    __ fcmps(v2, 0.0);                                 //	fcmp	s2, #0.0
    __ fcmpd(v12, 0.0);                                //	fcmp	d12, #0.0

    __ bind(forth);

/*
aarch64ops.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <back>:
   0:	8b8b71ef 	add	x15, x15, x11, asr #28
   4:	cb54fd0a 	sub	x10, x8, x20, lsr #63
   8:	ab49493c 	adds	x28, x9, x9, lsr #18
   c:	eb5e0331 	subs	x17, x25, x30, lsr #0
  10:	0b854ae3 	add	w3, w23, w5, asr #18
  14:	4b53428a 	sub	w10, w20, w19, lsr #16
  18:	2b83616d 	adds	w13, w11, w3, asr #24
  1c:	6b5a2ad2 	subs	w18, w22, w26, lsr #10
  20:	8a1d4638 	and	x24, x17, x29, lsl #17
  24:	aa559fb1 	orr	x17, x29, x21, lsr #39
  28:	ca520aa4 	eor	x4, x21, x18, lsr #2
  2c:	ea955c5b 	ands	x27, x2, x21, asr #23
  30:	0a893424 	and	w4, w1, w9, asr #13
  34:	2a524ca7 	orr	w7, w5, w18, lsr #19
  38:	4a52553e 	eor	w30, w9, w18, lsr #21
  3c:	6a09099c 	ands	w28, w12, w9, lsl #2
  40:	8a3a58e8 	bic	x8, x7, x26, lsl #22
  44:	aa71a273 	orn	x19, x19, x17, lsr #40
  48:	ca2904cd 	eon	x13, x6, x9, lsl #1
  4c:	eaadbaed 	bics	x13, x23, x13, asr #46
  50:	0a2f44ad 	bic	w13, w5, w15, lsl #17
  54:	2a2e4131 	orn	w17, w9, w14, lsl #16
  58:	4abc4487 	eon	w7, w4, w28, asr #17
  5c:	6a214b46 	bics	w6, w26, w1, lsl #18
  60:	110a8907 	add	w7, w8, #0x2a2
  64:	3105f8b8 	adds	w24, w5, #0x17e
  68:	51097313 	sub	w19, w24, #0x25c
  6c:	710c1618 	subs	w24, w16, #0x305
  70:	91096078 	add	x24, x3, #0x258
  74:	b10e3eb7 	adds	x23, x21, #0x38f
  78:	d10db8a9 	sub	x9, x5, #0x36e
  7c:	f10eb8e4 	subs	x4, x7, #0x3ae
  80:	120c03ac 	and	w12, w29, #0x100000
  84:	3202c520 	orr	w0, w9, #0xc0c0c0c0
  88:	521c10cc 	eor	w12, w6, #0x1f0
  8c:	720854a4 	ands	w4, w5, #0xff003fff
  90:	925eac4c 	and	x12, x2, #0xfffffffc00003fff
  94:	b243f3b9 	orr	x25, x29, #0xe3ffffffffffffff
  98:	d20499dd 	eor	x29, x14, #0xf007f007f007f007
  9c:	f25a28f1 	ands	x17, x7, #0x1ffc000000000
  a0:	14000000 	b	a0 <back+0xa0>
  a4:	17ffffd7 	b	0 <back>
  a8:	1400014c 	b	5d8 <forth>
  ac:	94000000 	bl	ac <back+0xac>
  b0:	97ffffd4 	bl	0 <back>
  b4:	94000149 	bl	5d8 <forth>
  b8:	34000006 	cbz	w6, b8 <back+0xb8>
  bc:	34fffa26 	cbz	w6, 0 <back>
  c0:	340028c6 	cbz	w6, 5d8 <forth>
  c4:	35000017 	cbnz	w23, c4 <back+0xc4>
  c8:	35fff9d7 	cbnz	w23, 0 <back>
  cc:	35002877 	cbnz	w23, 5d8 <forth>
  d0:	b4000003 	cbz	x3, d0 <back+0xd0>
  d4:	b4fff963 	cbz	x3, 0 <back>
  d8:	b4002803 	cbz	x3, 5d8 <forth>
  dc:	b5000001 	cbnz	x1, dc <back+0xdc>
  e0:	b5fff901 	cbnz	x1, 0 <back>
  e4:	b50027a1 	cbnz	x1, 5d8 <forth>
  e8:	10000009 	adr	x9, e8 <back+0xe8>
  ec:	10fff8a9 	adr	x9, 0 <back>
  f0:	10002749 	adr	x9, 5d8 <forth>
  f4:	9000000e 	adrp	x14, 0 <back>
  f8:	36100009 	tbz	w9, #2, f8 <back+0xf8>
  fc:	3617f829 	tbz	w9, #2, 0 <back>
 100:	361026c9 	tbz	w9, #2, 5d8 <forth>
 104:	37500001 	tbnz	w1, #10, 104 <back+0x104>
 108:	3757f7c1 	tbnz	w1, #10, 0 <back>
 10c:	37502661 	tbnz	w1, #10, 5d8 <forth>
 110:	128a05c1 	movn	w1, #0x502e
 114:	5283b668 	movz	w8, #0x1db3
 118:	72adf7a3 	movk	w3, #0x6fbd, lsl #16
 11c:	92ee586c 	movn	x12, #0x72c3, lsl #48
 120:	d2acf792 	movz	x18, #0x67bc, lsl #16
 124:	f2e87ade 	movk	x30, #0x43d6, lsl #48
 128:	93580fcc 	sbfiz	x12, x30, #40, #4
 12c:	33112392 	bfi	w18, w28, #15, #9
 130:	53030b2e 	lsl	w14, w25, #29
 134:	93425a06 	sbfx	x6, x16, #2, #21
 138:	b34621cb 	bfxil	x11, x14, #6, #3
 13c:	d34e37b2 	lsl	x18, x29, #50
 140:	13933760 	extr	w0, w27, w19, #13
 144:	93cc44e4 	extr	x4, x7, x12, #17
 148:	54000000 	b.eq	148 <back+0x148>
 14c:	54fff5a0 	b.eq	0 <back>
 150:	54002440 	b.eq	5d8 <forth>
 154:	54000001 	b.ne	154 <back+0x154>
 158:	54fff541 	b.ne	0 <back>
 15c:	540023e1 	b.ne	5d8 <forth>
 160:	54000002 	b.cs	160 <back+0x160>
 164:	54fff4e2 	b.cs	0 <back>
 168:	54002382 	b.cs	5d8 <forth>
 16c:	54000002 	b.cs	16c <back+0x16c>
 170:	54fff482 	b.cs	0 <back>
 174:	54002322 	b.cs	5d8 <forth>
 178:	54000003 	b.cc	178 <back+0x178>
 17c:	54fff423 	b.cc	0 <back>
 180:	540022c3 	b.cc	5d8 <forth>
 184:	54000003 	b.cc	184 <back+0x184>
 188:	54fff3c3 	b.cc	0 <back>
 18c:	54002263 	b.cc	5d8 <forth>
 190:	54000004 	b.mi	190 <back+0x190>
 194:	54fff364 	b.mi	0 <back>
 198:	54002204 	b.mi	5d8 <forth>
 19c:	54000005 	b.pl	19c <back+0x19c>
 1a0:	54fff305 	b.pl	0 <back>
 1a4:	540021a5 	b.pl	5d8 <forth>
 1a8:	54000006 	b.vs	1a8 <back+0x1a8>
 1ac:	54fff2a6 	b.vs	0 <back>
 1b0:	54002146 	b.vs	5d8 <forth>
 1b4:	54000007 	b.vc	1b4 <back+0x1b4>
 1b8:	54fff247 	b.vc	0 <back>
 1bc:	540020e7 	b.vc	5d8 <forth>
 1c0:	54000008 	b.hi	1c0 <back+0x1c0>
 1c4:	54fff1e8 	b.hi	0 <back>
 1c8:	54002088 	b.hi	5d8 <forth>
 1cc:	54000009 	b.ls	1cc <back+0x1cc>
 1d0:	54fff189 	b.ls	0 <back>
 1d4:	54002029 	b.ls	5d8 <forth>
 1d8:	5400000a 	b.ge	1d8 <back+0x1d8>
 1dc:	54fff12a 	b.ge	0 <back>
 1e0:	54001fca 	b.ge	5d8 <forth>
 1e4:	5400000b 	b.lt	1e4 <back+0x1e4>
 1e8:	54fff0cb 	b.lt	0 <back>
 1ec:	54001f6b 	b.lt	5d8 <forth>
 1f0:	5400000c 	b.gt	1f0 <back+0x1f0>
 1f4:	54fff06c 	b.gt	0 <back>
 1f8:	54001f0c 	b.gt	5d8 <forth>
 1fc:	5400000d 	b.le	1fc <back+0x1fc>
 200:	54fff00d 	b.le	0 <back>
 204:	54001ead 	b.le	5d8 <forth>
 208:	5400000e 	b.al	208 <back+0x208>
 20c:	54ffefae 	b.al	0 <back>
 210:	54001e4e 	b.al	5d8 <forth>
 214:	5400000f 	b.nv	214 <back+0x214>
 218:	54ffef4f 	b.nv	0 <back>
 21c:	54001def 	b.nv	5d8 <forth>
 220:	d40f5961 	svc	#0x7acb
 224:	d40d6802 	hvc	#0x6b40
 228:	d40af623 	smc	#0x57b1
 22c:	d4230600 	brk	#0x1830
 230:	d443d060 	hlt	#0x1e83
 234:	d503201f 	nop
 238:	d69f03e0 	eret
 23c:	d6bf03e0 	drps
 240:	d5033fdf 	isb
 244:	d503319f 	dsb	oshld
 248:	d50332bf 	dmb	oshst
 24c:	d61f0100 	br	x8
 250:	d63f0240 	blr	x18
 254:	c80c7dee 	stxr	w12, x14, [x15]
 258:	c81efd0e 	stlxr	w30, x14, [x8]
 25c:	c85f7e02 	ldxr	x2, [x16]
 260:	c85ffdaf 	ldaxr	x15, [x13]
 264:	c89ffda7 	stlr	x7, [x13]
 268:	c8dffe1e 	ldar	x30, [x16]
 26c:	88067c8a 	stxr	w6, w10, [x4]
 270:	8807fd31 	stlxr	w7, w17, [x9]
 274:	885f7c65 	ldxr	w5, [x3]
 278:	885fff26 	ldaxr	w6, [x25]
 27c:	889fffc6 	stlr	w6, [x30]
 280:	88dffda0 	ldar	w0, [x13]
 284:	48147f1a 	stxrh	w20, w26, [x24]
 288:	4818fe58 	stlxrh	w24, w24, [x18]
 28c:	485f7fd3 	ldxrh	w19, [x30]
 290:	485ffc7a 	ldaxrh	w26, [x3]
 294:	489ffd0c 	stlrh	w12, [x8]
 298:	48dfffcb 	ldarh	w11, [x30]
 29c:	08017f24 	stxrb	w1, w4, [x25]
 2a0:	0809ff10 	stlxrb	w9, w16, [x24]
 2a4:	085f7c64 	ldxrb	w4, [x3]
 2a8:	085ffca9 	ldaxrb	w9, [x5]
 2ac:	089ffe85 	stlrb	w5, [x20]
 2b0:	08dffeb1 	ldarb	w17, [x21]
 2b4:	c87f35c8 	ldxp	x8, x13, [x14]
 2b8:	c87fd9dc 	ldaxp	x28, x22, [x14]
 2bc:	c8315a8a 	stxp	w17, x10, x22, [x20]
 2c0:	c83cf741 	stlxp	w28, x1, x29, [x26]
 2c4:	887f10c0 	ldxp	w0, w4, [x6]
 2c8:	887f9ed1 	ldaxp	w17, w7, [x22]
 2cc:	88220677 	stxp	w2, w23, w1, [x19]
 2d0:	882fa46e 	stlxp	w15, w14, w9, [x3]
 2d4:	f81e3254 	str	x20, [x18,#-29]
 2d8:	b900235e 	str	w30, [x26,#32]
 2dc:	381e22a5 	strb	w5, [x21,#-30]
 2e0:	781f20d2 	strh	w18, [x6,#-14]
 2e4:	f85f32cb 	ldr	x11, [x22,#-13]
 2e8:	b858904e 	ldr	w14, [x2,#-119]
 2ec:	385ee219 	ldrb	w25, [x16,#-18]
 2f0:	785d9240 	ldrh	w0, [x18,#-39]
 2f4:	389f4261 	ldrsb	x1, [x19,#-12]
 2f8:	789dc159 	ldrsh	x25, [x10,#-36]
 2fc:	78de4281 	ldrsh	w1, [x20,#-28]
 300:	b880b109 	ldrsw	x9, [x8,#11]
 304:	fc51b0e4 	ldr	d4, [x7,#-229]
 308:	bc40130e 	ldr	s14, [x24,#1]
 30c:	fc057021 	str	d1, [x1,#87]
 310:	bd000a72 	str	s18, [x19,#8]
 314:	f8143f0c 	str	x12, [x24,#-189]!
 318:	b8188e98 	str	w24, [x20,#-120]!
 31c:	381f1cbc 	strb	w28, [x5,#-15]!
 320:	781f4d23 	strh	w3, [x9,#-12]!
 324:	f85c6d3a 	ldr	x26, [x9,#-58]!
 328:	b85e1d4d 	ldr	w13, [x10,#-31]!
 32c:	3840bfb3 	ldrb	w19, [x29,#11]!
 330:	785dffbb 	ldrh	w27, [x29,#-33]!
 334:	389f3c96 	ldrsb	x22, [x4,#-13]!
 338:	789c1d6c 	ldrsh	x12, [x11,#-63]!
 33c:	78dfaf5d 	ldrsh	w29, [x26,#-6]!
 340:	b89dced5 	ldrsw	x21, [x22,#-36]!
 344:	fc5d7f5e 	ldr	d30, [x26,#-41]!
 348:	bc408df1 	ldr	s17, [x15,#8]!
 34c:	fc132cc1 	str	d1, [x6,#-206]!
 350:	bc191ca2 	str	s2, [x5,#-111]!
 354:	f800f74d 	str	x13, [x26],#15
 358:	b80105f8 	str	w24, [x15],#16
 35c:	38000588 	strb	w8, [x12],#0
 360:	781c65dd 	strh	w29, [x14],#-58
 364:	f854a750 	ldr	x16, [x26],#-182
 368:	b85aa402 	ldr	w2, [x0],#-86
 36c:	385e5503 	ldrb	w3, [x8],#-27
 370:	785ee7c7 	ldrh	w7, [x30],#-18
 374:	3880551e 	ldrsb	x30, [x8],#5
 378:	789f5561 	ldrsh	x1, [x11],#-11
 37c:	78c1e5f3 	ldrsh	w19, [x15],#30
 380:	b88334c9 	ldrsw	x9, [x6],#51
 384:	fc5915dc 	ldr	d28, [x14],#-111
 388:	bc4235d9 	ldr	s25, [x14],#35
 38c:	fc01f40a 	str	d10, [x0],#31
 390:	bc1874f8 	str	s24, [x7],#-121
 394:	f836eabe 	str	x30, [x21,x22,sxtx]
 398:	b8235943 	str	w3, [x10,w3,uxtw #2]
 39c:	383e5bac 	strb	w12, [x29,w30,uxtw #0]
 3a0:	7832ea46 	strh	w6, [x18,x18,sxtx]
 3a4:	f8726b97 	ldr	x23, [x28,x18]
 3a8:	b87178ec 	ldr	w12, [x7,x17,lsl #2]
 3ac:	3878585c 	ldrb	w28, [x2,w24,uxtw #0]
 3b0:	787b7bc2 	ldrh	w2, [x30,x27,lsl #1]
 3b4:	38a0da19 	ldrsb	x25, [x16,w0,sxtw #0]
 3b8:	78befaf1 	ldrsh	x17, [x23,x30,sxtx #1]
 3bc:	78f44bbb 	ldrsh	w27, [x29,w20,uxtw]
 3c0:	b8bbfb40 	ldrsw	x0, [x26,x27,sxtx #2]
 3c4:	fc7b6890 	ldr	d16, [x4,x27]
 3c8:	bc73dbda 	ldr	s26, [x30,w19,sxtw #2]
 3cc:	fc31f8a2 	str	d2, [x5,x17,sxtx #3]
 3d0:	bc2d6bbc 	str	s28, [x29,x13]
 3d4:	f91a0ba1 	str	x1, [x29,#13328]
 3d8:	b9194b3e 	str	w30, [x25,#6472]
 3dc:	391ce1f8 	strb	w24, [x15,#1848]
 3e0:	791baae2 	strh	w2, [x23,#3540]
 3e4:	f958da92 	ldr	x18, [x20,#12720]
 3e8:	b95de58b 	ldr	w11, [x12,#7652]
 3ec:	39596b13 	ldrb	w19, [x24,#1626]
 3f0:	795acfa7 	ldrh	w7, [x29,#3430]
 3f4:	399e663a 	ldrsb	x26, [x17,#1945]
 3f8:	79985aee 	ldrsh	x14, [x23,#3116]
 3fc:	79dc4166 	ldrsh	w6, [x11,#3616]
 400:	b99c7cad 	ldrsw	x13, [x5,#7292]
 404:	fd5d8586 	ldr	d6, [x12,#15112]
 408:	bd5ee49d 	ldr	s29, [x4,#7908]
 40c:	fd1ac09b 	str	d27, [x4,#13696]
 410:	bd1d11d0 	str	s16, [x14,#7440]
 414:	5800001a 	ldr	x26, 414 <back+0x414>
 418:	18ffdf50 	ldr	w16, 0 <back>
 41c:	f892b100 	prfm	pldl1keep, [x8,#-213]
 420:	d8ffdf00 	prfm	pldl1keep, 0 <back>
 424:	f8a87b00 	prfm	pldl1keep, [x24,x8,lsl #3]
 428:	f99ad280 	prfm	pldl1keep, [x20,#13728]
 42c:	1a010200 	adc	w0, w16, w1
 430:	3a1401c3 	adcs	w3, w14, w20
 434:	5a060155 	sbc	w21, w10, w6
 438:	7a15036b 	sbcs	w11, w27, w21
 43c:	9a1800e8 	adc	x8, x7, x24
 440:	ba0600f1 	adcs	x17, x7, x6
 444:	da1600db 	sbc	x27, x6, x22
 448:	fa09025c 	sbcs	x28, x18, x9
 44c:	0b244c95 	add	w21, w4, w4, uxtw #3
 450:	2b2bc5c8 	adds	w8, w14, w11, sxtw #1
 454:	cb2565b8 	sub	x24, x13, x5, uxtx #1
 458:	6b3d8e6c 	subs	w12, w19, w29, sxtb #3
 45c:	8b3129e7 	add	x7, x15, w17, uxth #2
 460:	ab3548d6 	adds	x22, x6, w21, uxtw #2
 464:	cb30d39c 	sub	x28, x28, w16, sxtw #4
 468:	eb3ae58b 	subs	x11, x12, x26, sxtx #1
 46c:	3a4f5087 	ccmn	w4, w15, #0x7, pl
 470:	7a4cc02e 	ccmp	w1, w12, #0xe, gt
 474:	ba5a8262 	ccmn	x19, x26, #0x2, hi
 478:	fa43b047 	ccmp	x2, x3, #0x7, lt
 47c:	3a52da08 	ccmn	w16, #0x12, #0x8, le
 480:	7a4ea9ec 	ccmp	w15, #0xe, #0xc, ge
 484:	ba4fca69 	ccmn	x19, #0xf, #0x9, gt
 488:	fa57cb26 	ccmp	x25, #0x17, #0x6, gt
 48c:	1a9831a0 	csel	w0, w13, w24, cc
 490:	1a9326f1 	csinc	w17, w23, w19, cs
 494:	5a8f2350 	csinv	w16, w26, w15, cs
 498:	5a916467 	csneg	w7, w3, w17, vs
 49c:	9a8ad1dd 	csel	x29, x14, x10, le
 4a0:	9a942763 	csinc	x3, x27, x20, cs
 4a4:	da9313c3 	csinv	x3, x30, x19, ne
 4a8:	da9a9409 	csneg	x9, x0, x26, ls
 4ac:	5ac002b1 	rbit	w17, w21
 4b0:	5ac0054e 	rev16	w14, w10
 4b4:	5ac00b91 	rev	w17, w28
 4b8:	5ac011cf 	clz	w15, w14
 4bc:	5ac015da 	cls	w26, w14
 4c0:	dac001ed 	rbit	x13, x15
 4c4:	dac006a4 	rev16	x4, x21
 4c8:	dac00a3a 	rev32	x26, x17
 4cc:	dac00e6b 	rev	x11, x19
 4d0:	dac011d8 	clz	x24, x14
 4d4:	dac01613 	cls	x19, x16
 4d8:	1ad808bb 	udiv	w27, w5, w24
 4dc:	1ac30fb1 	sdiv	w17, w29, w3
 4e0:	1ad523a0 	lsl	w0, w29, w21
 4e4:	1ad526f3 	lsr	w19, w23, w21
 4e8:	1ac72a5c 	asr	w28, w18, w7
 4ec:	1ada2cc8 	ror	w8, w6, w26
 4f0:	9ad30b04 	udiv	x4, x24, x19
 4f4:	9ac80eca 	sdiv	x10, x22, x8
 4f8:	9ad92268 	lsl	x8, x19, x25
 4fc:	9ada2430 	lsr	x16, x1, x26
 500:	9ada286e 	asr	x14, x3, x26
 504:	9ad32c6f 	ror	x15, x3, x19
 508:	1b1e6dd6 	madd	w22, w14, w30, w27
 50c:	1b099e86 	msub	w6, w20, w9, w7
 510:	9b051470 	madd	x16, x3, x5, x5
 514:	9b098216 	msub	x22, x16, x9, x0
 518:	9b275a2b 	smaddl	x11, w17, w7, x22
 51c:	9b38e75a 	smsubl	x26, w26, w24, x25
 520:	9bb369d5 	umaddl	x21, w14, w19, x26
 524:	9ba79f40 	umsubl	x0, w26, w7, x7
 528:	1e2e0aa1 	fmul	s1, s21, s14
 52c:	1e351a99 	fdiv	s25, s20, s21
 530:	1e3b2a0d 	fadd	s13, s16, s27
 534:	1e323a89 	fsub	s9, s20, s18
 538:	1e3e084e 	fmul	s14, s2, s30
 53c:	1e7809e4 	fmul	d4, d15, d24
 540:	1e7a197c 	fdiv	d28, d11, d26
 544:	1e60281a 	fadd	d26, d0, d0
 548:	1e743936 	fsub	d22, d9, d20
 54c:	1e710ba4 	fmul	d4, d29, d17
 550:	1f1c32dd 	fmadd	s29, s22, s28, s12
 554:	1f1dcb26 	fmsub	s6, s25, s29, s18
 558:	1f3767c1 	fnmadd	s1, s30, s23, s25
 55c:	1f2310de 	fnmadd	s30, s6, s3, s4
 560:	1f453e56 	fmadd	d22, d18, d5, d15
 564:	1f5d8b4e 	fmsub	d14, d26, d29, d2
 568:	1f713d50 	fnmadd	d16, d10, d17, d15
 56c:	1f724392 	fnmadd	d18, d28, d18, d16
 570:	1e204179 	fmov	s25, s11
 574:	1e20c12c 	fabs	s12, s9
 578:	1e2141bc 	fneg	s28, s13
 57c:	1e21c009 	fsqrt	s9, s0
 580:	1e22c040 	fcvt	d0, s2
 584:	1e6041a5 	fmov	d5, d13
 588:	1e60c1e0 	fabs	d0, d15
 58c:	1e6142ca 	fneg	d10, d22
 590:	1e61c0d0 	fsqrt	d16, d6
 594:	1e624133 	fcvt	s19, d9
 598:	1e38032f 	fcvtzs	w15, s25
 59c:	9e3800ee 	fcvtzs	x14, s7
 5a0:	1e7802f1 	fcvtzs	w17, d23
 5a4:	9e7801eb 	fcvtzs	x11, d15
 5a8:	1e2200c6 	scvtf	s6, w6
 5ac:	9e2203c3 	scvtf	s3, x30
 5b0:	1e620246 	scvtf	d6, w18
 5b4:	9e620264 	scvtf	d4, x19
 5b8:	1e26023c 	fmov	w28, s17
 5bc:	9e66024b 	fmov	x11, d18
 5c0:	1e270259 	fmov	s25, w18
 5c4:	9e670313 	fmov	d19, x24
 5c8:	1e382220 	fcmp	s17, s24
 5cc:	1e662000 	fcmp	d0, d6
 5d0:	1e202048 	fcmp	s2, #0.0
 5d4:	1e602188 	fcmp	d12, #0.0
 */

  static const unsigned int insns[] =
  {
    0x8b8b71ef,     0xcb54fd0a,     0xab49493c,     0xeb5e0331,
    0x0b854ae3,     0x4b53428a,     0x2b83616d,     0x6b5a2ad2,
    0x8a1d4638,     0xaa559fb1,     0xca520aa4,     0xea955c5b,
    0x0a893424,     0x2a524ca7,     0x4a52553e,     0x6a09099c,
    0x8a3a58e8,     0xaa71a273,     0xca2904cd,     0xeaadbaed,
    0x0a2f44ad,     0x2a2e4131,     0x4abc4487,     0x6a214b46,
    0x110a8907,     0x3105f8b8,     0x51097313,     0x710c1618,
    0x91096078,     0xb10e3eb7,     0xd10db8a9,     0xf10eb8e4,
    0x120c03ac,     0x3202c520,     0x521c10cc,     0x720854a4,
    0x925eac4c,     0xb243f3b9,     0xd20499dd,     0xf25a28f1,
    0x14000000,     0x17ffffd7,     0x1400014c,     0x94000000,
    0x97ffffd4,     0x94000149,     0x34000006,     0x34fffa26,
    0x340028c6,     0x35000017,     0x35fff9d7,     0x35002877,
    0xb4000003,     0xb4fff963,     0xb4002803,     0xb5000001,
    0xb5fff901,     0xb50027a1,     0x10000009,     0x10fff8a9,
    0x10002749,     0x9000000e,     0x36100009,     0x3617f829,
    0x361026c9,     0x37500001,     0x3757f7c1,     0x37502661,
    0x128a05c1,     0x5283b668,     0x72adf7a3,     0x92ee586c,
    0xd2acf792,     0xf2e87ade,     0x93580fcc,     0x33112392,
    0x53030b2e,     0x93425a06,     0xb34621cb,     0xd34e37b2,
    0x13933760,     0x93cc44e4,     0x54000000,     0x54fff5a0,
    0x54002440,     0x54000001,     0x54fff541,     0x540023e1,
    0x54000002,     0x54fff4e2,     0x54002382,     0x54000002,
    0x54fff482,     0x54002322,     0x54000003,     0x54fff423,
    0x540022c3,     0x54000003,     0x54fff3c3,     0x54002263,
    0x54000004,     0x54fff364,     0x54002204,     0x54000005,
    0x54fff305,     0x540021a5,     0x54000006,     0x54fff2a6,
    0x54002146,     0x54000007,     0x54fff247,     0x540020e7,
    0x54000008,     0x54fff1e8,     0x54002088,     0x54000009,
    0x54fff189,     0x54002029,     0x5400000a,     0x54fff12a,
    0x54001fca,     0x5400000b,     0x54fff0cb,     0x54001f6b,
    0x5400000c,     0x54fff06c,     0x54001f0c,     0x5400000d,
    0x54fff00d,     0x54001ead,     0x5400000e,     0x54ffefae,
    0x54001e4e,     0x5400000f,     0x54ffef4f,     0x54001def,
    0xd40f5961,     0xd40d6802,     0xd40af623,     0xd4230600,
    0xd443d060,     0xd503201f,     0xd69f03e0,     0xd6bf03e0,
    0xd5033fdf,     0xd503319f,     0xd50332bf,     0xd61f0100,
    0xd63f0240,     0xc80c7dee,     0xc81efd0e,     0xc85f7e02,
    0xc85ffdaf,     0xc89ffda7,     0xc8dffe1e,     0x88067c8a,
    0x8807fd31,     0x885f7c65,     0x885fff26,     0x889fffc6,
    0x88dffda0,     0x48147f1a,     0x4818fe58,     0x485f7fd3,
    0x485ffc7a,     0x489ffd0c,     0x48dfffcb,     0x08017f24,
    0x0809ff10,     0x085f7c64,     0x085ffca9,     0x089ffe85,
    0x08dffeb1,     0xc87f35c8,     0xc87fd9dc,     0xc8315a8a,
    0xc83cf741,     0x887f10c0,     0x887f9ed1,     0x88220677,
    0x882fa46e,     0xf81e3254,     0xb900235e,     0x381e22a5,
    0x781f20d2,     0xf85f32cb,     0xb858904e,     0x385ee219,
    0x785d9240,     0x389f4261,     0x789dc159,     0x78de4281,
    0xb880b109,     0xfc51b0e4,     0xbc40130e,     0xfc057021,
    0xbd000a72,     0xf8143f0c,     0xb8188e98,     0x381f1cbc,
    0x781f4d23,     0xf85c6d3a,     0xb85e1d4d,     0x3840bfb3,
    0x785dffbb,     0x389f3c96,     0x789c1d6c,     0x78dfaf5d,
    0xb89dced5,     0xfc5d7f5e,     0xbc408df1,     0xfc132cc1,
    0xbc191ca2,     0xf800f74d,     0xb80105f8,     0x38000588,
    0x781c65dd,     0xf854a750,     0xb85aa402,     0x385e5503,
    0x785ee7c7,     0x3880551e,     0x789f5561,     0x78c1e5f3,
    0xb88334c9,     0xfc5915dc,     0xbc4235d9,     0xfc01f40a,
    0xbc1874f8,     0xf836eabe,     0xb8235943,     0x383e5bac,
    0x7832ea46,     0xf8726b97,     0xb87178ec,     0x3878585c,
    0x787b7bc2,     0x38a0da19,     0x78befaf1,     0x78f44bbb,
    0xb8bbfb40,     0xfc7b6890,     0xbc73dbda,     0xfc31f8a2,
    0xbc2d6bbc,     0xf91a0ba1,     0xb9194b3e,     0x391ce1f8,
    0x791baae2,     0xf958da92,     0xb95de58b,     0x39596b13,
    0x795acfa7,     0x399e663a,     0x79985aee,     0x79dc4166,
    0xb99c7cad,     0xfd5d8586,     0xbd5ee49d,     0xfd1ac09b,
    0xbd1d11d0,     0x5800001a,     0x18ffdf50,     0xf892b100,
    0xd8ffdf00,     0xf8a87b00,     0xf99ad280,     0x1a010200,
    0x3a1401c3,     0x5a060155,     0x7a15036b,     0x9a1800e8,
    0xba0600f1,     0xda1600db,     0xfa09025c,     0x0b244c95,
    0x2b2bc5c8,     0xcb2565b8,     0x6b3d8e6c,     0x8b3129e7,
    0xab3548d6,     0xcb30d39c,     0xeb3ae58b,     0x3a4f5087,
    0x7a4cc02e,     0xba5a8262,     0xfa43b047,     0x3a52da08,
    0x7a4ea9ec,     0xba4fca69,     0xfa57cb26,     0x1a9831a0,
    0x1a9326f1,     0x5a8f2350,     0x5a916467,     0x9a8ad1dd,
    0x9a942763,     0xda9313c3,     0xda9a9409,     0x5ac002b1,
    0x5ac0054e,     0x5ac00b91,     0x5ac011cf,     0x5ac015da,
    0xdac001ed,     0xdac006a4,     0xdac00a3a,     0xdac00e6b,
    0xdac011d8,     0xdac01613,     0x1ad808bb,     0x1ac30fb1,
    0x1ad523a0,     0x1ad526f3,     0x1ac72a5c,     0x1ada2cc8,
    0x9ad30b04,     0x9ac80eca,     0x9ad92268,     0x9ada2430,
    0x9ada286e,     0x9ad32c6f,     0x1b1e6dd6,     0x1b099e86,
    0x9b051470,     0x9b098216,     0x9b275a2b,     0x9b38e75a,
    0x9bb369d5,     0x9ba79f40,     0x1e2e0aa1,     0x1e351a99,
    0x1e3b2a0d,     0x1e323a89,     0x1e3e084e,     0x1e7809e4,
    0x1e7a197c,     0x1e60281a,     0x1e743936,     0x1e710ba4,
    0x1f1c32dd,     0x1f1dcb26,     0x1f3767c1,     0x1f2310de,
    0x1f453e56,     0x1f5d8b4e,     0x1f713d50,     0x1f724392,
    0x1e204179,     0x1e20c12c,     0x1e2141bc,     0x1e21c009,
    0x1e22c040,     0x1e6041a5,     0x1e60c1e0,     0x1e6142ca,
    0x1e61c0d0,     0x1e624133,     0x1e38032f,     0x9e3800ee,
    0x1e7802f1,     0x9e7801eb,     0x1e2200c6,     0x9e2203c3,
    0x1e620246,     0x9e620264,     0x1e26023c,     0x9e66024b,
    0x1e270259,     0x9e670313,     0x1e382220,     0x1e662000,
    0x1e202048,     0x1e602188, 
  };
// END  Generated code -- do not edit

  {
    bool ok = true;
    unsigned int *insns1 = (unsigned int *)entry;
    for (unsigned int i = 0; i < sizeof insns / sizeof insns[0]; i++) {
      if (insns[i] != insns1[i]) {
	ok = false;
	printf("Ours:\n");
	Disassembler::decode((address)&insns1[i], (address)&insns1[i+1]);
	printf("Theirs:\n");
	Disassembler::decode((address)&insns[i], (address)&insns[i+1]);
	printf("\n");
      }
    }
    assert(ok, "Assembler smoke test failed");
  }
#endif // ASSERT

#ifdef PRODUCT
#define BLOCK_COMMENT(str) /* nothing */
#else
#define BLOCK_COMMENT(str) __ block_comment(str)
#endif

#define BIND(label) bind(label); BLOCK_COMMENT(#label ":")

  {
    Label l, loop, empty;
    address a = __ pc();
    __ adr(r3, l);
    __ adrp(r4, l);
    __ bl(empty);
    __ movz(r0, 0);
    __ BIND(loop);
    __ subs(sp, r0, 10);
    __ br(Assembler::NE, l);
    __ add(r0, r0, 1u);
    __ adr(r3, loop);
    __ br(Assembler::AL, loop);
    __ BIND(l);
    __ BIND(empty);
    __ ret(lr);
    Disassembler::decode(a, __ pc());
    printf("\n");
  }
}

extern "C" {
  void das(uint64_t start, int len) {
    len <<= 2;
    if (len < 0)
      Disassembler::decode((address)start + len, (address)start);
    else
      Disassembler::decode((address)start, (address)start + len);
  }
}

#define gas_assert(ARG1) assert(ARG1, #ARG1)

// ------------- Stolen from binutils begin -------------------------------------

/* Build the accepted values for immediate logical SIMD instructions.
 *
 * The valid encodings of the immediate value are:
 *   opc<0> j:jjjjj  i:iii:ii  SIMD size  R             S
 *   1      ssssss   rrrrrr       64      UInt(rrrrrr)  UInt(ssssss)
 *   0      0sssss   0rrrrr       32      UInt(rrrrr)   UInt(sssss)
 *   0      10ssss   00rrrr       16      UInt(rrrr)    UInt(ssss)
 *   0      110sss   000rrr       8       UInt(rrr)     UInt(sss)
 *   0      1110ss   0000rr       4       UInt(rr)      UInt(ss)
 *   0      11110s   00000r       2       UInt(r)       UInt(s)
 *   other combinations                   UNPREDICTABLE
 *
 * Let's call E the SIMD size.
 *
 * The immediate value is: S+1 bits '1' rotated to the right by R.
 *
 * The total of valid encodings is 64^2 + 32^2 + ... + 2^2 = 5460.
 *
 * This means we have the following number of distinct values:
 *   - for S = E - 1, all values of R generate a word full of '1'
 *      so we have 2 + 4 + ... + 64 = 126 ways of encoding 0xf...f
 *   - for S != E - 1, all value are obviously distinct
 *      so we have #{ for all E: (E - 1) * R (where R = E) } values
 *        = 64*63 + 32*31 + ... + 2*1 = 5334
 *   - it is obvious that for two different values of E, if S != E - 1
 *      then we can't generate the same value.
 * So the total number of distinct values is 5334 + 1 = 5335 (out of
 * a total of 5460 valid encodings).
 */
#define TOTAL_IMM_NB  5334

typedef struct {
  uint64_t imm;
  uint32_t encoding;
} simd_imm_encoding_v2;

static simd_imm_encoding_v2 simd_immediates_v2[TOTAL_IMM_NB];

static int
simd_imm_encoding_cmp_v2(const void *i1, const void *i2)
{
  const simd_imm_encoding_v2 *imm1 = (const simd_imm_encoding_v2 *)i1;
  const simd_imm_encoding_v2 *imm2 = (const simd_imm_encoding_v2 *)i2;

  if (imm1->imm < imm2->imm)
    return -1;
  if (imm1->imm > imm2->imm)
    return +1;
  return 0;
}

/* immediate bitfield encoding
 * imm13<12> imm13<5:0> imm13<11:6> SIMD size R      S
 * 1         ssssss     rrrrrr      64        rrrrrr ssssss
 * 0         0sssss     0rrrrr      32        rrrrr  sssss
 * 0         10ssss     00rrrr      16        rrrr   ssss
 * 0         110sss     000rrr      8         rrr    sss
 * 0         1110ss     0000rr      4         rr     ss
 * 0         11110s     00000r      2         r      s
 */
static inline int encode_immediate_bitfield(int is64, uint32_t s, uint32_t r)
{
  return (is64 << 12) | (r << 6) | s;
}

static void
build_immediate_table_v2(void) __attribute__ ((constructor));

static void
build_immediate_table_v2(void)
{
  uint32_t log_e, e, s, r, s_mask;
  uint64_t mask, imm;
  int nb_imms;
  int is64;

  nb_imms = 0;
  for (log_e = 1; log_e <= 6; log_e++) {
    e = 1u << log_e;
    if (log_e == 6) {
      is64 = 1;
      mask = 0xffffffffffffffffull;
      s_mask = 0;
    } else {
      is64 = 0;
      mask = (1ull << e) - 1;
      /* log_e  s_mask
       *  1     ((1 << 4) - 1) << 2 = 111100
       *  2     ((1 << 3) - 1) << 3 = 111000
       *  3     ((1 << 2) - 1) << 4 = 110000
       *  4     ((1 << 1) - 1) << 5 = 100000
       *  5     ((1 << 0) - 1) << 6 = 000000
       */
      s_mask = ((1u << (5 - log_e)) - 1) << (log_e + 1);
    }
    for (s = 0; s < e - 1; s++) {
      for (r = 0; r < e; r++) {
        /* s+1 consecutive bits to 1 (s < 63) */
        imm = (1ull << (s + 1)) - 1;
        /* rotate right by r */
        if (r != 0)
          imm = (imm >> r) | ((imm << (e - r)) & mask);
        /* replicate the constant depending on SIMD size */
        switch (log_e) {
        case 1: imm = (imm <<  2) | imm;
        case 2: imm = (imm <<  4) | imm;
        case 3: imm = (imm <<  8) | imm;
        case 4: imm = (imm << 16) | imm;
        case 5: imm = (imm << 32) | imm;
        case 6:
          break;
        default:
          abort ();
        }
        simd_immediates_v2[nb_imms].imm = imm;
        simd_immediates_v2[nb_imms].encoding =
          encode_immediate_bitfield(is64, s | s_mask, r);
        nb_imms++;
      }
    }
  }
  gas_assert(nb_imms == TOTAL_IMM_NB);
  qsort(simd_immediates_v2, nb_imms,
        sizeof(simd_immediates_v2[0]), simd_imm_encoding_cmp_v2);
}

/* Create a valid encoding for imm.  Returns ffffffff since it's an invalid
   encoding.  */
uint32_t
asm_util::encode_immediate_v2(int is32, uint64_t imm)
{
  simd_imm_encoding_v2 imm_enc;
  const simd_imm_encoding_v2 *imm_encoding;

  if (is32) {
    /* Allow all zeros or all ones in top 32-bits, so that
       constant expressions like ~1 are permitted. */
    if (imm >> 32 != 0 && imm >> 32 != 0xffffffff)
      return 0xffffffff;
    /* Replicate the 32 lower bits to the 32 upper bits.  */
    imm &= 0xffffffff;
    imm |= imm << 32;
  }

  imm_enc.imm = imm;
  imm_encoding = (const simd_imm_encoding_v2 *)
    bsearch(&imm_enc, simd_immediates_v2, TOTAL_IMM_NB,
            sizeof(simd_immediates_v2[0]), simd_imm_encoding_cmp_v2);
  if (imm_encoding == NULL)
    return 0xffffffff;
  return imm_encoding->encoding;
}

// ------------- Stolen from binutils end -------------------------------------

void Assembler::br(Condition cc, Label &L) {
  if (L.is_bound()) {
    br(cc, target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    br(cc, pc());
  }
}

void Assembler::wrap_label(Label &L,
				 Assembler::uncond_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    (this->*insn)(pc());
  }
}

void Assembler::wrap_label(Register r, Label &L,
				 compare_and_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(r, target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    (this->*insn)(r, pc());
  }
}

void Assembler::wrap_label(Register r, int bitpos, Label &L,
				 test_and_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(r, bitpos, target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    (this->*insn)(r, bitpos, pc());
  }
}

void Assembler::wrap_label(Label &L, int prfop, prefetch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(target(L), prfop);
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    (this->*insn)(pc(), prfop);
  }
}


void MacroAssembler::pd_patch_instruction(address branch, address target) {
  long offset = (target - branch) >> 2;
  unsigned insn = *(unsigned*)branch;
  if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {
    // Load register (literal)
    Instruction_aarch64::spatch(branch, 23, 5, offset);
  } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
    // Unconditional branch (immediate)
    Instruction_aarch64::spatch(branch, 25, 0, offset);
  } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
    // Conditional branch (immediate)
    Instruction_aarch64::spatch(branch, 23, 5, offset);
  } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
    // Compare & branch (immediate)
    Instruction_aarch64::spatch(branch, 23, 5, offset);
  } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
    // Test & branch (immediate)
    Instruction_aarch64::spatch(branch, 18, 5, offset);
  } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
    // PC-rel. addressing
    offset = target-branch;
    int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;
    offset >>= shift;
    int offset_lo = offset & 3;
    offset >>= 2;
    Instruction_aarch64::spatch(branch, 18, 5, offset);
    Instruction_aarch64::spatch(branch, 30, 29, offset_lo);
  } else {
    abort();
  }
}

bool Assembler::operand_valid_for_logical_immdiate(int is32, uint64_t imm) {
  return encode_immediate_v2(is32, imm) != 0xffffffff;
}

int AbstractAssembler::code_fill_byte() { Unimplemented(); }

// added to make this compile

REGISTER_DEFINITION(Register, noreg);

void MacroAssembler::call_VM_base(Register oop_result,
				  Register java_thread,
				  Register last_java_sp,
				  address  entry_point,
				  int      number_of_arguments,
				  bool     check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             bool check_exceptions) { Unimplemented(); }


void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             Register arg_3,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
			     Register last_java_sp,
			     address entry_point,
			     int number_of_arguments,
			     bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
			     bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             Register arg_3,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::check_and_handle_earlyret(Register java_thread) {Unimplemented(); }

void MacroAssembler::align(int modulus) {
  while (offset() % modulus != 0) nop();
}

void MacroAssembler::check_and_handle_popframe(Register java_thread) { Unimplemented(); }

RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
                                                      Register tmp,
                                                      int offset) { Unimplemented(); return RegisterOrConstant(r0); }

void MacroAssembler::verify_oop(Register reg, const char* s) {
  if (!VerifyOops) return;

  Unimplemented();
}

void Assembler::bang_stack_with_offset(int offset) { Unimplemented(); }

void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) { Unimplemented(); }

void MacroAssembler::null_check(Register reg, int offset) { Unimplemented(); }

// MacroAssembler protected routines needed to implement
// public methods

void MacroAssembler::mov_immediate64(Register dst, u_int64_t imm64)
{
  if (operand_valid_for_logical_immdiate(0, imm64)) {
    orr(dst, zr, imm64);
  } else {
    // we can use a combination of MOVZ or MOVN with
    // MOVK to build up the constant
    u_int64_t imm_h[4];
    int zero_count = 0;
    int neg_count = 0;
    int i;
    for (i = 0; i < 4; i++) {
      imm_h[i] = ((imm64 >> (i * 16)) & 0xffffL);
      if (imm_h[i] == 0) {
	zero_count++;
      } else if (imm_h[i] == 0xffffL) {
	neg_count++;
      }
    }
    if (zero_count == 3) {
      // one MOVZ will do
      for (i = 0; i < 3; i++) {
	if (imm_h[i] != 0L) {
	  movz(dst, (u_int32_t)imm_h[i], (i << 4));
	  break;
	}
      }
    } else if (neg_count == 3) {
      // one MOVN will do
      for (int i = 0; i < 3; i++) {
	if (imm_h[i] != 0xffffL) {
	  movn(dst, (u_int32_t)imm_h[i], (i << 4));
	  break;
	}
      }
    } else if (zero_count == 2) {
      // one MOVZ and one MOVK will do
      for (i = 0; i < 3; i++) {
	if (imm_h[i] != 0L) {
	  movz(dst, (u_int32_t)imm_h[i], (i << 4));
	  i++;
	  break;
	}
      }
      for (;i < 3; i++) {
	if (imm_h[i] != 0L) {
	  movk(dst, (u_int32_t)imm_h[i], (i << 4));
	  break;
	}
      }
    } else if (neg_count == 2) {
      // one MOVN and one MOVK will do
      for (i = 0; i < 3; i++) {
	if (imm_h[i] != 0xffffL) {
	  movn(dst, (u_int32_t)imm_h[i], (i << 4));
	  i++;
	  break;
	}
      }
      for (;i < 3; i++) {
	if (imm_h[i] != 0xffffL) {
	  movk(dst, (u_int32_t)imm_h[i], (i << 4));
	  break;
	}
      }
    } else if (zero_count == 1) {
      // one MOVZ and two MOVKs will do
      for (i = 0; i < 3; i++) {
	if (imm_h[i] != 0L) {
	  movz(dst, (u_int32_t)imm_h[i], (i << 4));
	  i++;
	  break;
	}
      }
      for (;i < 3; i++) {
	if (imm_h[i] != 0x0L) {
	  movk(dst, (u_int32_t)imm_h[i], (i << 4));
	  break;
	}
      }
    } else if (neg_count == 1) {
      // one MOVN and two MOVKs will do
      for (i = 0; i < 3; i++) {
	if (imm_h[i] != 0xffffL) {
	  movn(dst, (u_int32_t)imm_h[i], (i << 4));
	  i++;
	  break;
	}
      }
      for (;i < 3; i++) {
	if (imm_h[i] != 0xffffL) {
	  movk(dst, (u_int32_t)imm_h[i], (i << 4));
	  break;
	}
      }
    } else {
      // use a MOVZ and 3 MOVKs (makes it easier to debug)
      movz(dst, (u_int32_t)imm_h[0], 0);
      for (i = 1; i < 3; i++) {
	movk(dst, (u_int32_t)imm_h[i], (i << 4));
      }
    }
  }
}

void MacroAssembler::mov_immediate32(Register dst, u_int32_t imm32)
{
  if (operand_valid_for_logical_immdiate(1, imm32)) {
    orrw(dst, zr, imm32);
  } else {
    // we can use MOVZ, MOVN or two calls to MOVK to build up the
    // constant
    u_int32_t imm_h[2];
    imm_h[0] = imm32 & 0xffff;
    imm_h[1] = ((imm32 >> 16) & 0xffff);
    if (imm_h[0] == 0) {
      movzw(dst, imm_h[1], 16);
    } else if (imm_h[0] == 0xffff) {
      movnw(dst, imm_h[1], 16);
    } else if (imm_h[1] == 0) {
      movzw(dst, imm_h[0], 0);
    } else if (imm_h[1] == 0xffff) {
      movnw(dst, imm_h[0], 0);
    } else {
      // use a MOVZ and MOVK (makes it easier to debug)
      movzw(dst, imm_h[0], 0);
      movkw(dst, imm_h[1], 16);
    }
  }
}

// MacroAssembler routines found actually to be needed

void MacroAssembler::call(Register entry)
{
  br(entry);
}

void MacroAssembler::push(Register src)
{
  str(src, Address(pre(sp, -1 * wordSize)));
}

void MacroAssembler::pop(Register dst)
{
  ldr(dst, Address(post(sp, 1 * wordSize)));
}

// Note: load_unsigned_short used to be called load_unsigned_word.
int MacroAssembler::load_unsigned_short(Register dst, Address src) {
  int off = offset();
  ldrh(dst, src);
  return off;
}

int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
  int off = offset();
  ldrb(dst, src);
  return off;
}

void MacroAssembler::pusha() {
  // need to push all registers including original sp
  for (Register reg = r0; reg <= r30; reg = as_Register(reg->encoding() + 1))
    push(reg);
  // cannot push sp as str will treat it as zr !!!
  mov(r0, sp);
  push(r0);
  // re-establish r0? we probably only use pusha when we are about to
  // exit so we don't necessarily have to do this but let's leave the
  // registers as they were just in case.
  ldr(r0, Address(sp, 31 * wordSize));
}

void MacroAssembler::stop(const char* msg) {
  address ip = pc();
  pusha();
  mov(c_rarg0, (address)msg);
  mov(c_rarg1, (address)ip);
  mov(c_rarg2, sp);
  // round down sp to 16 byte boundary
  // (assumes literal will encode directly)
  andr(sp, c_rarg2, ~0xfUL);
  mov(c_rarg3, CAST_FROM_FN_PTR(address, MacroAssembler::debug64));
  call(c_rarg3);
  hlt(0);
}

void MacroAssembler::enter()
{
  push(lr);
  push(rfp);
  mov(rfp, sp);
}

void MacroAssembler::leave()
{
  mov(sp, rfp);
  pop(rfp);
  pop(lr);
}

void MacroAssembler::reinit_heapbase()
{
  if (UseCompressedOops) {
    mov(rheapbase, (address)Universe::narrow_oop_base_addr());
  }
}

#ifndef PRODUCT
extern "C" void findpc(intptr_t x);
#endif

void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[])
{
  // In order to get locks to work, we need to fake a in_VM state
  if (ShowMessageBoxOnError ) {
    JavaThread* thread = JavaThread::current();
    JavaThreadState saved_state = thread->thread_state();
    thread->set_thread_state(_thread_in_vm);
#ifndef PRODUCT
    if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
      ttyLocker ttyl;
      BytecodeCounter::print();
    }
#endif
    // To see where a verify_oop failed, get $ebx+40/X for this frame.
    // XXX correct this offset for amd64
    // This is the value of eip which points to where verify_oop will return.
    if (os::message_box(msg, "Execution stopped, print registers?")) {
      ttyLocker ttyl;
      tty->print_cr(" pc = 0x%016lx", pc);
#ifndef PRODUCT
      tty->cr();
      findpc(pc);
      tty->cr();
#endif
      tty->print_cr(" r0 = 0x%016lx", regs[0]);
      tty->print_cr(" r1 = 0x%016lx", regs[1]);
      tty->print_cr(" r2 = 0x%016lx", regs[2]);
      tty->print_cr(" r3 = 0x%016lx", regs[3]);
      tty->print_cr(" r4 = 0x%016lx", regs[4]);
      tty->print_cr(" r5 = 0x%016lx", regs[5]);
      tty->print_cr(" r6 = 0x%016lx", regs[6]);
      tty->print_cr(" r7 = 0x%016lx", regs[7]);
      tty->print_cr(" r8 = 0x%016lx", regs[8]);
      tty->print_cr(" r9 = 0x%016lx", regs[9]);
      tty->print_cr("r10 = 0x%016lx", regs[10]);
      tty->print_cr("r11 = 0x%016lx", regs[11]);
      tty->print_cr("r12 = 0x%016lx", regs[12]);
      tty->print_cr("r13 = 0x%016lx", regs[13]);
      tty->print_cr("r14 = 0x%016lx", regs[14]);
      tty->print_cr("r15 = 0x%016lx", regs[15]);
      tty->print_cr("r16 = 0x%016lx", regs[16]);
      tty->print_cr("r17 = 0x%016lx", regs[17]);
      tty->print_cr("r18 = 0x%016lx", regs[18]);
      tty->print_cr("r19 = 0x%016lx", regs[19]);
      tty->print_cr("r20 = 0x%016lx", regs[20]);
      tty->print_cr("r21 = 0x%016lx", regs[21]);
      tty->print_cr("r22 = 0x%016lx", regs[22]);
      tty->print_cr("r23 = 0x%016lx", regs[23]);
      tty->print_cr("r24 = 0x%016lx", regs[24]);
      tty->print_cr("r25 = 0x%016lx", regs[25]);
      tty->print_cr("r26 = 0x%016lx", regs[26]);
      tty->print_cr("r27 = 0x%016lx", regs[27]);
      tty->print_cr("r28 = 0x%016lx", regs[28]);
      tty->print_cr("r30 = 0x%016lx", regs[30]);
      tty->print_cr("r31 = 0x%016lx", regs[31]);
      BREAKPOINT;
    }
    ThreadStateTransition::transition(thread, _thread_in_vm, saved_state);
  } else {
    ttyLocker ttyl;
    ::tty->print_cr("=============== DEBUG MESSAGE: %s ================\n",
                    msg);
    assert(false, err_msg("DEBUG MESSAGE: %s", msg));
  }
}

// routine to generate an x86 prolog for a stub function which
// bootstraps into the generated ARM code which directly follows the
// stub
//
// the argument encodes the number of general and fp registers
// passed by the caller and the callng convention (currently just
// the number of general registers and assumes C argument passing)

extern "C" {
int aarch64_stub_prolog_size();
void aarch64_stub_prolog();
void setup_arm_sim(void *sp, int calltype);
}

void MacroAssembler::c_stub_prolog(u_int64_t calltype)
{
  // the addresses for the x86 to ARM entry code we need to use
  address start = pc();
  // printf("start = %lx\n", start);
  int byteCount =  aarch64_stub_prolog_size();
  // printf("byteCount = %x\n", byteCount);
  int instructionCount = (byteCount + 3)/ 4;
  // printf("instructionCount = %x\n", instructionCount);
  for (int i = 0; i < instructionCount; i++) {
    nop();
  }

  memcpy(start, (void*)aarch64_stub_prolog, byteCount);

  // write the address of the setup routine and the call format at the
  // end of into the copied code
  u_int64_t *patch_end = (u_int64_t *)(start + byteCount);
  patch_end[-2] = (u_int64_t)setup_arm_sim;
  patch_end[-1] = calltype;
}
