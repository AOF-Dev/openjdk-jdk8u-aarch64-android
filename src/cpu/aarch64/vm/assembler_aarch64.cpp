/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

#undef TARGET_ARCH_x86
#define TARGET_ARCH_AARCH64
#define CPU_X86_VM_REGISTER_X86_HPP

#include <stdio.h>
#include <sys/types.h>

#include "precompiled.hpp"
// #include "assembler_aarch64.inline.hpp"
#include "asm/assembler.hpp"
#include "assembler_aarch64.hpp"

#include "compiler/disassembler.hpp"

// #include "gc_interface/collectedHeap.inline.hpp"
// #include "interpreter/interpreter.hpp"
// #include "memory/cardTableModRefBS.hpp"
// #include "memory/resourceArea.hpp"
// #include "prims/methodHandles.hpp"
// #include "runtime/biasedLocking.hpp"
// #include "runtime/interfaceSupport.hpp"
// #include "runtime/objectMonitor.hpp"
// #include "runtime/os.hpp"
// #include "runtime/sharedRuntime.hpp"
// #include "runtime/stubRoutines.hpp"
// #ifndef SERIALGC
// #include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
// #include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
// #include "gc_implementation/g1/heapRegion.hpp"
// #endif


extern "C" void entry(CodeBuffer *cb);

#define __ _masm.

void entry(CodeBuffer *cb) {
  Assembler _masm(cb);
  address entry = __ pc();

  // Smoke test for assembler

#if ASSERT
// BEGIN  Generated code -- do not edit
// Generated by aarch64-asmtest.py
    Label back, forth;
    __ bind(back);

// ArithOp
    __ add(r15, r29, r3, Assembler::asr, 37);     //	add	x15, x29, x3, asr #37
    __ sub(r21, r24, r30, Assembler::lsl, 34);    //	sub	x21, x24, x30, lsl #34
    __ adds(r22, r14, r18, Assembler::asr, 51);   //	adds	x22, x14, x18, asr #51
    __ subs(r29, r6, r30, Assembler::asr, 18);    //	subs	x29, x6, x30, asr #18
    __ addw(r3, r19, r19, Assembler::lsr, 31);    //	add	w3, w19, w19, lsr #31
    __ subw(r12, r8, r17, Assembler::lsr, 18);    //	sub	w12, w8, w17, lsr #18
    __ addsw(r1, r3, r6, Assembler::asr, 0);      //	adds	w1, w3, w6, asr #0
    __ subsw(r1, r1, r13, Assembler::lsr, 9);     //	subs	w1, w1, w13, lsr #9
    __ andr(r15, r18, r8, Assembler::asr, 63);    //	and	x15, x18, x8, asr #63
    __ orr(r25, r6, r19, Assembler::lsr, 34);     //	orr	x25, x6, x19, lsr #34
    __ eor(r26, r4, r24, Assembler::asr, 43);     //	eor	x26, x4, x24, asr #43
    __ ands(r2, r8, r3, Assembler::asr, 25);      //	ands	x2, x8, x3, asr #25
    __ andw(r11, r30, r5, Assembler::lsr, 1);     //	and	w11, w30, w5, lsr #1
    __ orrw(r25, r12, r29, Assembler::lsl, 19);   //	orr	w25, w12, w29, lsl #19
    __ eorw(r27, r14, r25, Assembler::lsl, 6);    //	eor	w27, w14, w25, lsl #6
    __ andsw(r27, r15, r12, Assembler::asr, 25);  //	ands	w27, w15, w12, asr #25
    __ bic(r9, r25, r26, Assembler::lsr, 25);     //	bic	x9, x25, x26, lsr #25
    __ orn(r1, r5, r27, Assembler::lsr, 19);      //	orn	x1, x5, x27, lsr #19
    __ eon(r21, r3, r25, Assembler::lsl, 18);     //	eon	x21, x3, x25, lsl #18
    __ bics(r29, r16, r2, Assembler::lsl, 0);     //	bics	x29, x16, x2, lsl #0
    __ bicw(r24, r3, r27, Assembler::lsl, 30);    //	bic	w24, w3, w27, lsl #30
    __ ornw(r5, r15, r9, Assembler::lsl, 0);      //	orn	w5, w15, w9, lsl #0
    __ eonw(r16, r13, r0, Assembler::lsr, 4);     //	eon	w16, w13, w0, lsr #4
    __ bicsw(r18, r10, r21, Assembler::lsl, 25);  //	bics	w18, w10, w21, lsl #25

// AddSubImmOp
    __ addw(r9, r4, 764u);                        //	add	w9, w4, #764
    __ addsw(r14, r7, 825u);                      //	adds	w14, w7, #825
    __ subw(r16, r19, 1014u);                     //	sub	w16, w19, #1014
    __ subsw(r16, r9, 419u);                      //	subs	w16, w9, #419
    __ add(r24, r5, 314u);                        //	add	x24, x5, #314
    __ adds(r18, r11, 439u);                      //	adds	x18, x11, #439
    __ sub(r30, r20, 181u);                       //	sub	x30, x20, #181
    __ subs(r30, r11, 974u);                      //	subs	x30, x11, #974

// LogicalImmOp
    __ andw(r9, r4, 33553408ul);                  //	and	w9, w4, #0x1fffc00
    __ orrw(r10, r11, 4294709247ul);              //	orr	w10, w11, #0xfffc0fff
    __ eorw(r12, r15, 4294950919ul);              //	eor	w12, w15, #0xffffc007
    __ andsw(r30, r15, 1ul);                      //	ands	w30, w15, #0x1
    __ andr(r17, r14, 18444492273897963519ul);    //	and	x17, x14, #0xfff80000001fffff
    __ orr(r29, r25, 211106232532992ul);          //	orr	x29, x25, #0xc00000000000
    __ eor(r16, r2, 36028797018962944ul);         //	eor	x16, x2, #0x7ffffffffffc00
    __ ands(r19, r16, 18410715276690588671ul);    //	ands	x19, x16, #0xff800000000003ff

// AbsOp
    __ b(__ pc());                                //	b	.
    __ b(back);                                   //	b	back
    __ b(forth);                                  //	b	forth
    __ bl(__ pc());                               //	bl	.
    __ bl(back);                                  //	bl	back
    __ bl(forth);                                 //	bl	forth

// RegAndAbsOp
    __ cbzw(r28, __ pc());                        //	cbz	w28, .
    __ cbzw(r28, back);                           //	cbz	w28, back
    __ cbzw(r28, forth);                          //	cbz	w28, forth
    __ cbnzw(r2, __ pc());                        //	cbnz	w2, .
    __ cbnzw(r2, back);                           //	cbnz	w2, back
    __ cbnzw(r2, forth);                          //	cbnz	w2, forth
    __ cbz(r21, __ pc());                         //	cbz	x21, .
    __ cbz(r21, back);                            //	cbz	x21, back
    __ cbz(r21, forth);                           //	cbz	x21, forth
    __ cbnz(r17, __ pc());                        //	cbnz	x17, .
    __ cbnz(r17, back);                           //	cbnz	x17, back
    __ cbnz(r17, forth);                          //	cbnz	x17, forth
    __ adr(r30, __ pc());                         //	adr	x30, .
    __ adr(r30, back);                            //	adr	x30, back
    __ adr(r30, forth);                           //	adr	x30, forth
    __ adrp(r10, __ pc());                        //	adrp	x10, .

// RegImmAbsOp
    __ tbz(r26, 0, __ pc());                      //	tbz	x26, #0, .
    __ tbz(r26, 0, back);                         //	tbz	x26, #0, back
    __ tbz(r26, 0, forth);                        //	tbz	x26, #0, forth
    __ tbnz(r11, 10, __ pc());                    //	tbnz	x11, #10, .
    __ tbnz(r11, 10, back);                       //	tbnz	x11, #10, back
    __ tbnz(r11, 10, forth);                      //	tbnz	x11, #10, forth

// MoveWideImmOp
    __ movnw(r6, 21495, 16);                      //	movn	w6, #21495, lsl 16
    __ movzw(r21, 22284, 0);                      //	movz	w21, #22284, lsl 0
    __ movkw(r12, 14435, 0);                      //	movk	w12, #14435, lsl 0
    __ movn(r8, 26487, 16);                       //	movn	x8, #26487, lsl 16
    __ movz(r23, 20532, 16);                      //	movz	x23, #20532, lsl 16
    __ movk(r27, 24570, 32);                      //	movk	x27, #24570, lsl 32

// BitfieldOp
    __ sbfm(r18, r25, 28, 12);                    //	sbfm	x18, x25, #28, #12
    __ bfmw(r27, r15, 8, 17);                     //	bfm	w27, w15, #8, #17
    __ ubfmw(r17, r6, 5, 9);                      //	ubfm	w17, w6, #5, #9
    __ sbfm(r15, r19, 1, 0);                      //	sbfm	x15, x19, #1, #0
    __ bfm(r5, r18, 15, 25);                      //	bfm	x5, x18, #15, #25
    __ ubfm(r1, r22, 31, 23);                     //	ubfm	x1, x22, #31, #23

// ExtractOp
    __ extrw(r15, r29, r22, 18);                  //	extr	w15, w29, w22, #18
    __ extr(r20, r15, r15, 21);                   //	extr	x20, x15, x15, #21

// CondBranchOp
    __ br(Assembler::EQ, __ pc());                //	b.EQ	.
    __ br(Assembler::EQ, back);                   //	b.EQ	back
    __ br(Assembler::EQ, forth);                  //	b.EQ	forth
    __ br(Assembler::NE, __ pc());                //	b.NE	.
    __ br(Assembler::NE, back);                   //	b.NE	back
    __ br(Assembler::NE, forth);                  //	b.NE	forth
    __ br(Assembler::HS, __ pc());                //	b.HS	.
    __ br(Assembler::HS, back);                   //	b.HS	back
    __ br(Assembler::HS, forth);                  //	b.HS	forth
    __ br(Assembler::CS, __ pc());                //	b.CS	.
    __ br(Assembler::CS, back);                   //	b.CS	back
    __ br(Assembler::CS, forth);                  //	b.CS	forth
    __ br(Assembler::LO, __ pc());                //	b.LO	.
    __ br(Assembler::LO, back);                   //	b.LO	back
    __ br(Assembler::LO, forth);                  //	b.LO	forth
    __ br(Assembler::CC, __ pc());                //	b.CC	.
    __ br(Assembler::CC, back);                   //	b.CC	back
    __ br(Assembler::CC, forth);                  //	b.CC	forth
    __ br(Assembler::MI, __ pc());                //	b.MI	.
    __ br(Assembler::MI, back);                   //	b.MI	back
    __ br(Assembler::MI, forth);                  //	b.MI	forth
    __ br(Assembler::PL, __ pc());                //	b.PL	.
    __ br(Assembler::PL, back);                   //	b.PL	back
    __ br(Assembler::PL, forth);                  //	b.PL	forth
    __ br(Assembler::VS, __ pc());                //	b.VS	.
    __ br(Assembler::VS, back);                   //	b.VS	back
    __ br(Assembler::VS, forth);                  //	b.VS	forth
    __ br(Assembler::VC, __ pc());                //	b.VC	.
    __ br(Assembler::VC, back);                   //	b.VC	back
    __ br(Assembler::VC, forth);                  //	b.VC	forth
    __ br(Assembler::HI, __ pc());                //	b.HI	.
    __ br(Assembler::HI, back);                   //	b.HI	back
    __ br(Assembler::HI, forth);                  //	b.HI	forth
    __ br(Assembler::LS, __ pc());                //	b.LS	.
    __ br(Assembler::LS, back);                   //	b.LS	back
    __ br(Assembler::LS, forth);                  //	b.LS	forth
    __ br(Assembler::GE, __ pc());                //	b.GE	.
    __ br(Assembler::GE, back);                   //	b.GE	back
    __ br(Assembler::GE, forth);                  //	b.GE	forth
    __ br(Assembler::LT, __ pc());                //	b.LT	.
    __ br(Assembler::LT, back);                   //	b.LT	back
    __ br(Assembler::LT, forth);                  //	b.LT	forth
    __ br(Assembler::GT, __ pc());                //	b.GT	.
    __ br(Assembler::GT, back);                   //	b.GT	back
    __ br(Assembler::GT, forth);                  //	b.GT	forth
    __ br(Assembler::LE, __ pc());                //	b.LE	.
    __ br(Assembler::LE, back);                   //	b.LE	back
    __ br(Assembler::LE, forth);                  //	b.LE	forth
    __ br(Assembler::AL, __ pc());                //	b.AL	.
    __ br(Assembler::AL, back);                   //	b.AL	back
    __ br(Assembler::AL, forth);                  //	b.AL	forth
    __ br(Assembler::NV, __ pc());                //	b.NV	.
    __ br(Assembler::NV, back);                   //	b.NV	back
    __ br(Assembler::NV, forth);                  //	b.NV	forth

// ImmOp
    __ svc(9724);                                 //	svc	#9724
    __ hvc(19765);                                //	hvc	#19765
    __ smc(14033);                                //	smc	#14033
    __ brk(19608);                                //	brk	#19608
    __ hlt(4198);                                 //	hlt	#4198

// Op
    __ nop();                                     //	nop	
    __ eret();                                    //	eret	
    __ drps();                                    //	drps	
    __ isb();                                     //	isb	

// SystemOp
    __ dsb(Assembler::ISH);                       //	dsb	ISH
    __ dmb(Assembler::NSHLD);                     //	dmb	NSHLD

// OneRegOp
    __ br(r13);                                   //	br	x13
    __ blr(r2);                                   //	blr	x2

// LoadStoreExclusiveOp
    __ stxr(r28, r16, r3);                        //	stxr	w28, x16, [x3]
    __ stlxr(r24, r11, r1);                       //	stlxr	w24, x11, [x1]
    __ ldxr(r7, r2);                              //	ldxr	x7, [x2]
    __ ldaxr(r30, r18);                           //	ldaxr	x30, [x18]
    __ stlr(r12, r15);                            //	stlr	x12, [x15]
    __ ldar(r11, r6);                             //	ldar	x11, [x6]

// LoadStoreExclusiveOp
    __ stxrw(r14, r22, r8);                       //	stxr	w14, w22, [x8]
    __ stlxrw(r26, r21, r17);                     //	stlxr	w26, w21, [x17]
    __ ldxrw(r28, r3);                            //	ldxr	w28, [x3]
    __ ldaxrw(r23, r0);                           //	ldaxr	w23, [x0]
    __ stlrw(r2, r6);                             //	stlr	w2, [x6]
    __ ldarw(r4, r18);                            //	ldar	w4, [x18]

// LoadStoreExclusiveOp
    __ stxrh(r11, r22, r21);                      //	stxrh	w11, w22, [x21]
    __ stlxrh(r15, r25, r7);                      //	stlxrh	w15, w25, [x7]
    __ ldxrh(r26, r0);                            //	ldxrh	w26, [x0]
    __ ldaxrh(r7, r27);                           //	ldaxrh	w7, [x27]
    __ stlrh(r12, r20);                           //	stlrh	w12, [x20]
    __ ldarh(r17, r24);                           //	ldarh	w17, [x24]

// LoadStoreExclusiveOp
    __ stxrb(r16, r19, r19);                      //	stxrb	w16, w19, [x19]
    __ stlxrb(r28, r12, r23);                     //	stlxrb	w28, w12, [x23]
    __ ldxrb(r16, r11);                           //	ldxrb	w16, [x11]
    __ ldaxrb(r2, r1);                            //	ldaxrb	w2, [x1]
    __ stlrb(r30, r22);                           //	stlrb	w30, [x22]
    __ ldarb(r20, r14);                           //	ldarb	w20, [x14]

// LoadStoreExclusiveOp
    __ ldxp(r24, r15, r0);                        //	ldxp	x24, x15, [x0]
    __ ldaxp(r1, r10, r12);                       //	ldaxp	x1, x10, [x12]
    __ stxp(r3, r0, r26, r13);                    //	stxp	w3, x0, x26, [x13]
    __ stlxp(r0, r10, r6, r28);                   //	stlxp	w0, x10, x6, [x28]

// LoadStoreExclusiveOp
    __ ldxpw(r2, r21, r17);                       //	ldxp	w2, w21, [x17]
    __ ldaxpw(r12, r3, r12);                      //	ldaxp	w12, w3, [x12]
    __ stxpw(r5, r6, r7, r19);                    //	stxp	w5, w6, w7, [x19]
    __ stlxpw(r27, r20, r9, r27);                 //	stlxp	w27, w20, w9, [x27]

// base_plus_unscaled_offset 
// LoadStoreOp
    __ str(r9, Address(r5, -127));                //	str	x9, [x5, -127]
    __ strw(r19, Address(r23, 3));                //	str	w19, [x23, 3]
    __ strb(r14, Address(r6, 1));                 //	strb	w14, [x6, 1]
    __ strh(r19, Address(r16, -33));              //	strh	w19, [x16, -33]
    __ ldr(r7, Address(r16, -159));               //	ldr	x7, [x16, -159]
    __ ldrw(r25, Address(r27, 8));                //	ldr	w25, [x27, 8]
    __ ldrb(r3, Address(r14, 12));                //	ldrb	w3, [x14, 12]
    __ ldrh(r12, Address(r7, -22));               //	ldrh	w12, [x7, -22]
    __ ldrsb(r4, Address(r16, -23));              //	ldrsb	x4, [x16, -23]
    __ ldrsh(r20, Address(r14, 7));               //	ldrsh	x20, [x14, 7]
    __ ldrshw(r18, Address(r16, 2));              //	ldrsh	w18, [x16, 2]
    __ ldrsw(r4, Address(r0, 59));                //	ldrsw	x4, [x0, 59]
    __ ldrd(v12, Address(r30, -137));             //	ldr	d12, [x30, -137]
    __ ldrs(v29, Address(r21, -78));              //	ldr	s29, [x21, -78]
    __ strd(v6, Address(r29, 55));                //	str	d6, [x29, 55]
    __ strs(v28, Address(r10, -126));             //	str	s28, [x10, -126]

// pre 
// LoadStoreOp
    __ str(r26, Address(__ pre(r26, -2)));        //	str	x26, [x26, -2]!
    __ strw(r2, Address(__ pre(r11, -98)));       //	str	w2, [x11, -98]!
    __ strb(r20, Address(__ pre(r18, -21)));      //	strb	w20, [x18, -21]!
    __ strh(r1, Address(__ pre(r5, -11)));        //	strh	w1, [x5, -11]!
    __ ldr(r8, Address(__ pre(r22, -111)));       //	ldr	x8, [x22, -111]!
    __ ldrw(r6, Address(__ pre(r0, 30)));         //	ldr	w6, [x0, 30]!
    __ ldrb(r23, Address(__ pre(r20, 15)));       //	ldrb	w23, [x20, 15]!
    __ ldrh(r17, Address(__ pre(r21, -29)));      //	ldrh	w17, [x21, -29]!
    __ ldrsb(r12, Address(__ pre(r20, -19)));     //	ldrsb	x12, [x20, -19]!
    __ ldrsh(r7, Address(__ pre(r13, -51)));      //	ldrsh	x7, [x13, -51]!
    __ ldrshw(r26, Address(__ pre(r11, -39)));    //	ldrsh	w26, [x11, -39]!
    __ ldrsw(r8, Address(__ pre(r21, 7)));        //	ldrsw	x8, [x21, 7]!
    __ ldrd(v16, Address(__ pre(r5, 38)));        //	ldr	d16, [x5, 38]!
    __ ldrs(v25, Address(__ pre(r6, 15)));        //	ldr	s25, [x6, 15]!
    __ strd(v21, Address(__ pre(r4, -41)));       //	str	d21, [x4, -41]!
    __ strs(v28, Address(__ pre(r1, -13)));       //	str	s28, [x1, -13]!

// post 
// LoadStoreOp
    __ str(r27, Address(__ post(r2, 30)));        //	str	x27, [x2], 30
    __ strw(r3, Address(__ post(r3, -12)));       //	str	w3, [x3], -12
    __ strb(r11, Address(__ post(r5, -15)));      //	strb	w11, [x5], -15
    __ strh(r29, Address(__ post(r27, 9)));       //	strh	w29, [x27], 9
    __ ldr(r27, Address(__ post(r6, 125)));       //	ldr	x27, [x6], 125
    __ ldrw(r4, Address(__ post(r19, -90)));      //	ldr	w4, [x19], -90
    __ ldrb(r17, Address(__ post(r25, -3)));      //	ldrb	w17, [x25], -3
    __ ldrh(r26, Address(__ post(r26, -6)));      //	ldrh	w26, [x26], -6
    __ ldrsb(r21, Address(__ post(r30, -5)));     //	ldrsb	x21, [x30], -5
    __ ldrsh(r13, Address(__ post(r2, 15)));      //	ldrsh	x13, [x2], 15
    __ ldrshw(r16, Address(__ post(r11, -51)));   //	ldrsh	w16, [x11], -51
    __ ldrsw(r4, Address(__ post(r22, -20)));     //	ldrsw	x4, [x22], -20
    __ ldrd(v16, Address(__ post(r20, 62)));      //	ldr	d16, [x20], 62
    __ ldrs(v29, Address(__ post(r30, -89)));     //	ldr	s29, [x30], -89
    __ strd(v1, Address(__ post(r5, -194)));      //	str	d1, [x5], -194
    __ strs(v4, Address(__ post(r6, -85)));       //	str	s4, [x6], -85

// base_plus_reg 
// LoadStoreOp
    __ str(r10, Address(r12, r30));               //	str	x10, [x12, x30]
    __ strw(r11, Address(r13, r9));               //	str	w11, [x13, x9]
    __ strb(r25, Address(r17, r30));              //	strb	w25, [x17, x30]
    __ strh(r8, Address(r10, r6));                //	strh	w8, [x10, x6]
    __ ldr(r7, Address(r18, r1));                 //	ldr	x7, [x18, x1]
    __ ldrw(r1, Address(r4, r30));                //	ldr	w1, [x4, x30]
    __ ldrb(r4, Address(r14, r10));               //	ldrb	w4, [x14, x10]
    __ ldrh(r25, Address(r10, r24));              //	ldrh	w25, [x10, x24]
    __ ldrsb(r29, Address(r21, r19));             //	ldrsb	x29, [x21, x19]
    __ ldrsh(r30, Address(r7, r21));              //	ldrsh	x30, [x7, x21]
    __ ldrshw(r10, Address(r17, r22));            //	ldrsh	w10, [x17, x22]
    __ ldrsw(r2, Address(r22, r28));              //	ldrsw	x2, [x22, x28]
    __ ldrd(v24, Address(r18, r11));              //	ldr	d24, [x18, x11]
    __ ldrs(v24, Address(r5, r4));                //	ldr	s24, [x5, x4]
    __ strd(v20, Address(r22, r16));              //	str	d20, [x22, x16]
    __ strs(v29, Address(r21, r11));              //	str	s29, [x21, x11]

// base_plus_scaled_offset 
// LoadStoreOp
    __ str(r3, Address(r9, 14600));               //	str	x3, [x9, 14600]
    __ strw(r28, Address(r5, 6884));              //	str	w28, [x5, 6884]
    __ strb(r26, Address(r12, 2016));             //	strb	w26, [x12, 2016]
    __ strh(r29, Address(r8, 3344));              //	strh	w29, [x8, 3344]
    __ ldr(r30, Address(r12, 13160));             //	ldr	x30, [x12, 13160]
    __ ldrw(r20, Address(r25, 6784));             //	ldr	w20, [x25, 6784]
    __ ldrb(r16, Address(r12, 1735));             //	ldrb	w16, [x12, 1735]
    __ ldrh(r25, Address(r29, 3186));             //	ldrh	w25, [x29, 3186]
    __ ldrsb(r7, Address(r26, 1567));             //	ldrsb	x7, [x26, 1567]
    __ ldrsh(r25, Address(r5, 3794));             //	ldrsh	x25, [x5, 3794]
    __ ldrshw(r22, Address(r13, 3824));           //	ldrsh	w22, [x13, 3824]
    __ ldrsw(r20, Address(r25, 7096));            //	ldrsw	x20, [x25, 7096]
    __ ldrd(v27, Address(r8, 16008));             //	ldr	d27, [x8, 16008]
    __ ldrs(v6, Address(r15, 7904));              //	ldr	s6, [x15, 7904]
    __ strd(v5, Address(r21, 13880));             //	str	d5, [x21, 13880]
    __ strs(v19, Address(r21, 6252));             //	str	s19, [x21, 6252]

// pcrel 
// LoadStoreOp
    __ ldr(r14, __ pc());                         //	ldr	x14, .
    __ ldrw(r30, back);                           //	ldr	w30, back

// LoadStoreOp
    __ prfm(Address(r0, 37));                     //	prfm	PLDL1KEEP, [x0, 37]

// LoadStoreOp
    __ prfm(__ pc());                             //	prfm	PLDL1KEEP, .

// LoadStoreOp
    __ prfm(Address(r0, r11));                    //	prfm	PLDL1KEEP, [x0, x11]

// LoadStoreOp
    __ prfm(Address(r24, 15072));                 //	prfm	PLDL1KEEP, [x24, 15072]

// AddSubCarryOp
    __ adcw(r22, r9, r16);                        //	adc	w22, w9, w16
    __ adcsw(r24, r14, r19);                      //	adcs	w24, w14, w19
    __ sbcw(r11, r24, r30);                       //	sbc	w11, w24, w30
    __ sbcsw(r1, r17, r5);                        //	sbcs	w1, w17, w5
    __ adc(r13, r14, r15);                        //	adc	x13, x14, x15
    __ adcs(r27, r12, r2);                        //	adcs	x27, x12, x2
    __ sbc(r11, r30, r22);                        //	sbc	x11, x30, x22
    __ sbcs(r12, r12, r10);                       //	sbcs	x12, x12, x10

// AddSubExtendedOp
    __ addw(r29, r27, r18, ext::sxtw, 4);         //	add	w29, w27, w18, sxtw #4
    __ addsw(r10, r16, r15, ext::uxth, 2);        //	adds	w10, w16, w15, uxth #2
    __ sub(r7, r17, r22, ext::uxtb, 3);           //	sub	x7, x17, x22, uxtb #3
    __ subsw(r8, r22, r23, ext::sxtb, 3);         //	subs	w8, w22, w23, sxtb #3
    __ add(r25, r6, r30, ext::sxth, 1);           //	add	x25, x6, x30, sxth #1
    __ adds(r9, r16, r7, ext::uxtx, 1);           //	adds	x9, x16, x7, uxtx #1
    __ sub(r13, r6, r14, ext::uxtx, 3);           //	sub	x13, x6, x14, uxtx #3
    __ subs(r22, r6, r25, ext::sxth, 1);          //	subs	x22, x6, x25, sxth #1

// ConditionalCompareOp
    __ ccmnw(r26, r18, 13u, Assembler::NE);       //	ccmn	w26, w18, #13, NE
    __ ccmpw(r16, r30, 2u, Assembler::VC);        //	ccmp	w16, w30, #2, VC
    __ ccmn(r0, r23, 10u, Assembler::LT);         //	ccmn	x0, x23, #10, LT
    __ ccmp(r6, r1, 11u, Assembler::GE);          //	ccmp	x6, x1, #11, GE

// ConditionalCompareImmedOp
    __ ccmnw(r27, 8, 14, Assembler::PL);          //	ccmn	w27, #8, #14, PL
    __ ccmpw(r22, 30, 12, Assembler::VC);         //	ccmp	w22, #30, #12, VC
    __ ccmn(r10, 3, 5, Assembler::PL);            //	ccmn	x10, #3, #5, PL
    __ ccmp(r15, 19, 12, Assembler::NE);          //	ccmp	x15, #19, #12, NE

// ConditionalSelectOp
    __ cselw(r6, r23, r14, Assembler::PL);        //	csel	w6, w23, w14, PL
    __ csincw(r21, r21, r18, Assembler::GT);      //	csinc	w21, w21, w18, GT
    __ csinvw(r10, r10, r5, Assembler::MI);       //	csinv	w10, w10, w5, MI
    __ csnegw(r18, r22, r29, Assembler::GT);      //	csneg	w18, w22, w29, GT
    __ csel(r20, r0, r2, Assembler::CC);          //	csel	x20, x0, x2, CC
    __ csinc(r10, r24, r21, Assembler::LS);       //	csinc	x10, x24, x21, LS
    __ csinv(r20, r2, r25, Assembler::LS);        //	csinv	x20, x2, x25, LS
    __ csneg(r28, r21, r15, Assembler::LE);       //	csneg	x28, x21, x15, LE

// TwoRegOp
    __ rbitw(r25, r27);                           //	rbit	w25, w27
    __ rev16w(r30, r1);                           //	rev16	w30, w1
    __ revw(r14, r0);                             //	rev	w14, w0
    __ clzw(r15, r4);                             //	clz	w15, w4
    __ clsw(r13, r22);                            //	cls	w13, w22
    __ rbit(r14, r4);                             //	rbit	x14, x4
    __ rev16(r13, r17);                           //	rev16	x13, x17
    __ rev32(r24, r7);                            //	rev32	x24, x7
    __ rev(r1, r21);                              //	rev	x1, x21
    __ clz(r21, r19);                             //	clz	x21, x19
    __ cls(r18, r28);                             //	cls	x18, x28

// ThreeRegOp
    __ udivw(r3, r6, r3);                         //	udiv	w3, w6, w3
    __ sdivw(r29, r11, r2);                       //	sdiv	w29, w11, w2
    __ lslvw(r21, r9, r13);                       //	lslv	w21, w9, w13
    __ lsrvw(r17, r23, r18);                      //	lsrv	w17, w23, w18
    __ asrvw(r27, r5, r30);                       //	asrv	w27, w5, w30
    __ rorvw(r22, r18, r17);                      //	rorv	w22, w18, w17
    __ udiv(r13, r10, r29);                       //	udiv	x13, x10, x29
    __ sdiv(r2, r15, r14);                        //	sdiv	x2, x15, x14
    __ lslv(r2, r10, r8);                         //	lslv	x2, x10, x8
    __ lsrv(r10, r17, r24);                       //	lsrv	x10, x17, x24
    __ asrv(r6, r10, r24);                        //	asrv	x6, x10, x24
    __ rorv(r11, r8, r23);                        //	rorv	x11, x8, x23

// FourRegMulOp
    __ maddw(r3, r14, r10, r7);                   //	madd	w3, w14, w10, w7
    __ msubw(r25, r9, r15, r17);                  //	msub	w25, w9, w15, w17
    __ madd(r30, r10, r4, r3);                    //	madd	x30, x10, x4, x3
    __ msub(r2, r14, r26, r13);                   //	msub	x2, x14, x26, x13
    __ smaddl(r13, r12, r0, r20);                 //	smaddl	x13, w12, w0, x20
    __ smsubl(r0, r24, r27, r12);                 //	smsubl	x0, w24, w27, x12
    __ umaddl(r21, r1, r8, r29);                  //	umaddl	x21, w1, w8, x29
    __ umsubl(r1, r14, r25, r12);                 //	umsubl	x1, w14, w25, x12

// ThreeRegFloatOp
    __ fmuls(v4, v21, v23);                       //	fmul	s4, s21, s23
    __ fdivs(v3, v3, v21);                        //	fdiv	s3, s3, s21
    __ fadds(v20, v20, v20);                      //	fadd	s20, s20, s20
    __ fsubs(v17, v12, v5);                       //	fsub	s17, s12, s5
    __ fmuls(v3, v10, v23);                       //	fmul	s3, s10, s23
    __ fmuld(v1, v8, v12);                        //	fmul	d1, d8, d12
    __ fdivd(v28, v4, v1);                        //	fdiv	d28, d4, d1
    __ faddd(v24, v25, v5);                       //	fadd	d24, d25, d5
    __ fsubd(v3, v9, v22);                        //	fsub	d3, d9, d22
    __ fmuld(v27, v27, v14);                      //	fmul	d27, d27, d14

// FourRegFloatOp
    __ fmadds(v13, v10, v13, v26);                //	fmadd	s13, s10, s13, s26
    __ fmsubs(v12, v27, v29, v7);                 //	fmsub	s12, s27, s29, s7
    __ fnmadds(v23, v1, v1, v26);                 //	fnmadd	s23, s1, s1, s26
    __ fnmadds(v8, v8, v20, v5);                  //	fnmadd	s8, s8, s20, s5
    __ fmaddd(v14, v26, v27, v27);                //	fmadd	d14, d26, d27, d27
    __ fmsubd(v3, v7, v28, v20);                  //	fmsub	d3, d7, d28, d20
    __ fnmaddd(v4, v16, v15, v16);                //	fnmadd	d4, d16, d15, d16
    __ fnmaddd(v29, v25, v3, v19);                //	fnmadd	d29, d25, d3, d19

// TwoRegFloatOp
    __ fmovs(v18, v23);                           //	fmov	s18, s23
    __ fabss(v27, v5);                            //	fabs	s27, s5
    __ fnegs(v30, v6);                            //	fneg	s30, s6
    __ fsqrts(v16, v19);                          //	fsqrt	s16, s19
    __ fcvts(v30, v28);                           //	fcvt	d30, s28
    __ fmovd(v24, v9);                            //	fmov	d24, d9
    __ fabsd(v8, v18);                            //	fabs	d8, d18
    __ fnegd(v4, v12);                            //	fneg	d4, d12
    __ fsqrtd(v28, v3);                           //	fsqrt	d28, d3
    __ fcvtd(v26, v4);                            //	fcvt	s26, d4

// FloatConvertOp
    __ fcvtzsw(r4, v21);                          //	fcvtzs	w4, s21
    __ fcvtzs(r23, v18);                          //	fcvtzs	x23, s18
    __ fcvtzdw(r17, v22);                         //	fcvtzs	w17, d22
    __ fcvtzd(r11, v18);                          //	fcvtzs	x11, d18
    __ scvtfws(v29, r5);                          //	scvtf	s29, w5
    __ scvtfs(v6, r12);                           //	scvtf	s6, x12
    __ scvtfwd(v18, r15);                         //	scvtf	d18, w15
    __ scvtfd(v16, r4);                           //	scvtf	d16, x4
    __ fmovs(r28, v20);                           //	fmov	w28, s20
    __ fmovd(r6, v14);                            //	fmov	x6, d14
    __ fmovs(v19, r0);                            //	fmov	s19, w0
    __ fmovd(v7, r19);                            //	fmov	d7, x19

// TwoRegFloatOp
    __ fcmps(v28, v29);                           //	fcmp	s28, s29
    __ fcmpd(v1, v28);                            //	fcmp	d1, d28
    __ fcmps(v23, 0.0);                           //	fcmp	s23, #0.0
    __ fcmpd(v13, 0.0);                           //	fcmp	d13, #0.0

    __ bind(forth);

/*
aarch64ops.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <back>:
   0:	8b8397af 	add	x15, x29, x3, asr #37
   4:	cb1e8b15 	sub	x21, x24, x30, lsl #34
   8:	ab92cdd6 	adds	x22, x14, x18, asr #51
   c:	eb9e48dd 	subs	x29, x6, x30, asr #18
  10:	0b537e63 	add	w3, w19, w19, lsr #31
  14:	4b51490c 	sub	w12, w8, w17, lsr #18
  18:	2b860061 	adds	w1, w3, w6, asr #0
  1c:	6b4d2421 	subs	w1, w1, w13, lsr #9
  20:	8a88fe4f 	and	x15, x18, x8, asr #63
  24:	aa5388d9 	orr	x25, x6, x19, lsr #34
  28:	ca98ac9a 	eor	x26, x4, x24, asr #43
  2c:	ea836502 	ands	x2, x8, x3, asr #25
  30:	0a4507cb 	and	w11, w30, w5, lsr #1
  34:	2a1d4d99 	orr	w25, w12, w29, lsl #19
  38:	4a1919db 	eor	w27, w14, w25, lsl #6
  3c:	6a8c65fb 	ands	w27, w15, w12, asr #25
  40:	8a7a6729 	bic	x9, x25, x26, lsr #25
  44:	aa7b4ca1 	orn	x1, x5, x27, lsr #19
  48:	ca394875 	eon	x21, x3, x25, lsl #18
  4c:	ea22021d 	bics	x29, x16, x2
  50:	0a3b7878 	bic	w24, w3, w27, lsl #30
  54:	2a2901e5 	orn	w5, w15, w9
  58:	4a6011b0 	eon	w16, w13, w0, lsr #4
  5c:	6a356552 	bics	w18, w10, w21, lsl #25
  60:	110bf089 	add	w9, w4, #0x2fc
  64:	310ce4ee 	adds	w14, w7, #0x339
  68:	510fda70 	sub	w16, w19, #0x3f6
  6c:	71068d30 	subs	w16, w9, #0x1a3
  70:	9104e8b8 	add	x24, x5, #0x13a
  74:	b106dd72 	adds	x18, x11, #0x1b7
  78:	d102d69e 	sub	x30, x20, #0xb5
  7c:	f10f397e 	subs	x30, x11, #0x3ce
  80:	12163889 	and	w9, w4, #0x1fffc00
  84:	320e656a 	orr	w10, w11, #0xfffc0fff
  88:	521251ec 	eor	w12, w15, #0xffffc007
  8c:	720001fe 	ands	w30, w15, #0x1
  90:	924d85d1 	and	x17, x14, #0xfff80000001fffff
  94:	b252073d 	orr	x29, x25, #0xc00000000000
  98:	d276b050 	eor	x16, x2, #0x7ffffffffffc00
  9c:	f2494a13 	ands	x19, x16, #0xff800000000003ff
  a0:	14000000 	b	a0 <back+0xa0>
  a4:	17ffffd7 	b	0 <back>
  a8:	1400014c 	b	5d8 <forth>
  ac:	94000000 	bl	ac <back+0xac>
  b0:	97ffffd4 	bl	0 <back>
  b4:	94000149 	bl	5d8 <forth>
  b8:	3400001c 	cbz	w28, b8 <back+0xb8>
  bc:	34fffa3c 	cbz	w28, 0 <back>
  c0:	340028dc 	cbz	w28, 5d8 <forth>
  c4:	35000002 	cbnz	w2, c4 <back+0xc4>
  c8:	35fff9c2 	cbnz	w2, 0 <back>
  cc:	35002862 	cbnz	w2, 5d8 <forth>
  d0:	b4000015 	cbz	x21, d0 <back+0xd0>
  d4:	b4fff975 	cbz	x21, 0 <back>
  d8:	b4002815 	cbz	x21, 5d8 <forth>
  dc:	b5000011 	cbnz	x17, dc <back+0xdc>
  e0:	b5fff911 	cbnz	x17, 0 <back>
  e4:	b50027b1 	cbnz	x17, 5d8 <forth>
  e8:	1000001e 	adr	x30, e8 <back+0xe8>
  ec:	10fff8be 	adr	x30, 0 <back>
  f0:	1000275e 	adr	x30, 5d8 <forth>
  f4:	9000000a 	adrp	x10, 0 <back>
  f8:	3600001a 	tbz	w26, #0, f8 <back+0xf8>
  fc:	3607f83a 	tbz	w26, #0, 0 <back>
 100:	360026da 	tbz	w26, #0, 5d8 <forth>
 104:	3750000b 	tbnz	w11, #10, 104 <back+0x104>
 108:	3757f7cb 	tbnz	w11, #10, 0 <back>
 10c:	3750266b 	tbnz	w11, #10, 5d8 <forth>
 110:	12aa7ee6 	movn	w6, #0x53f7, lsl #16
 114:	528ae195 	movz	w21, #0x570c
 118:	72870c6c 	movk	w12, #0x3863
 11c:	92aceee8 	movn	x8, #0x6777, lsl #16
 120:	d2aa0697 	movz	x23, #0x5034, lsl #16
 124:	f2cbff5b 	movk	x27, #0x5ffa, lsl #32
 128:	935c3332 	sbfiz	x18, x25, #36, #13
 12c:	330845fb 	bfxil	w27, w15, #8, #10
 130:	530524d1 	ubfx	w17, w6, #5, #5
 134:	9341026f 	sbfiz	x15, x19, #63, #1
 138:	b34f6645 	bfxil	x5, x18, #15, #11
 13c:	d35f5ec1 	ubfiz	x1, x22, #33, #24
 140:	13964baf 	extr	w15, w29, w22, #18
 144:	93cf55f4 	ror	x20, x15, #21
 148:	54000000 	b.eq	148 <back+0x148>
 14c:	54fff5a0 	b.eq	0 <back>
 150:	54002440 	b.eq	5d8 <forth>
 154:	54000001 	b.ne	154 <back+0x154>
 158:	54fff541 	b.ne	0 <back>
 15c:	540023e1 	b.ne	5d8 <forth>
 160:	54000002 	b.cs	160 <back+0x160>
 164:	54fff4e2 	b.cs	0 <back>
 168:	54002382 	b.cs	5d8 <forth>
 16c:	54000002 	b.cs	16c <back+0x16c>
 170:	54fff482 	b.cs	0 <back>
 174:	54002322 	b.cs	5d8 <forth>
 178:	54000003 	b.cc	178 <back+0x178>
 17c:	54fff423 	b.cc	0 <back>
 180:	540022c3 	b.cc	5d8 <forth>
 184:	54000003 	b.cc	184 <back+0x184>
 188:	54fff3c3 	b.cc	0 <back>
 18c:	54002263 	b.cc	5d8 <forth>
 190:	54000004 	b.mi	190 <back+0x190>
 194:	54fff364 	b.mi	0 <back>
 198:	54002204 	b.mi	5d8 <forth>
 19c:	54000005 	b.pl	19c <back+0x19c>
 1a0:	54fff305 	b.pl	0 <back>
 1a4:	540021a5 	b.pl	5d8 <forth>
 1a8:	54000006 	b.vs	1a8 <back+0x1a8>
 1ac:	54fff2a6 	b.vs	0 <back>
 1b0:	54002146 	b.vs	5d8 <forth>
 1b4:	54000007 	b.vc	1b4 <back+0x1b4>
 1b8:	54fff247 	b.vc	0 <back>
 1bc:	540020e7 	b.vc	5d8 <forth>
 1c0:	54000008 	b.hi	1c0 <back+0x1c0>
 1c4:	54fff1e8 	b.hi	0 <back>
 1c8:	54002088 	b.hi	5d8 <forth>
 1cc:	54000009 	b.ls	1cc <back+0x1cc>
 1d0:	54fff189 	b.ls	0 <back>
 1d4:	54002029 	b.ls	5d8 <forth>
 1d8:	5400000a 	b.ge	1d8 <back+0x1d8>
 1dc:	54fff12a 	b.ge	0 <back>
 1e0:	54001fca 	b.ge	5d8 <forth>
 1e4:	5400000b 	b.lt	1e4 <back+0x1e4>
 1e8:	54fff0cb 	b.lt	0 <back>
 1ec:	54001f6b 	b.lt	5d8 <forth>
 1f0:	5400000c 	b.gt	1f0 <back+0x1f0>
 1f4:	54fff06c 	b.gt	0 <back>
 1f8:	54001f0c 	b.gt	5d8 <forth>
 1fc:	5400000d 	b.le	1fc <back+0x1fc>
 200:	54fff00d 	b.le	0 <back>
 204:	54001ead 	b.le	5d8 <forth>
 208:	5400000e 	b.al	208 <back+0x208>
 20c:	54ffefae 	b.al	0 <back>
 210:	54001e4e 	b.al	5d8 <forth>
 214:	5400000f 	b.nv	214 <back+0x214>
 218:	54ffef4f 	b.nv	0 <back>
 21c:	54001def 	b.nv	5d8 <forth>
 220:	d404bf81 	svc	#0x25fc
 224:	d409a6a2 	hvc	#0x4d35
 228:	d406da23 	smc	#0x36d1
 22c:	d4299300 	brk	#0x4c98
 230:	d4420cc0 	hlt	#0x1066
 234:	d503201f 	nop
 238:	d69f03e0 	eret
 23c:	d6bf03e0 	drps
 240:	d5033fdf 	isb
 244:	d5033b9f 	dsb	ish
 248:	d50335bf 	dmb	nshld
 24c:	d61f01a0 	br	x13
 250:	d63f0040 	blr	x2
 254:	c81c7c70 	stxr	w28, x16, [x3]
 258:	c818fc2b 	stlxr	w24, x11, [x1]
 25c:	c85f7c47 	ldxr	x7, [x2]
 260:	c85ffe5e 	ldaxr	x30, [x18]
 264:	c89ffdec 	stlr	x12, [x15]
 268:	c8dffccb 	ldar	x11, [x6]
 26c:	880e7d16 	stxr	w14, w22, [x8]
 270:	881afe35 	stlxr	w26, w21, [x17]
 274:	885f7c7c 	ldxr	w28, [x3]
 278:	885ffc17 	ldaxr	w23, [x0]
 27c:	889ffcc2 	stlr	w2, [x6]
 280:	88dffe44 	ldar	w4, [x18]
 284:	480b7eb6 	stxrh	w11, w22, [x21]
 288:	480ffcf9 	stlxrh	w15, w25, [x7]
 28c:	485f7c1a 	ldxrh	w26, [x0]
 290:	485fff67 	ldaxrh	w7, [x27]
 294:	489ffe8c 	stlrh	w12, [x20]
 298:	48dfff11 	ldarh	w17, [x24]
 29c:	08107e73 	stxrb	w16, w19, [x19]
 2a0:	081cfeec 	stlxrb	w28, w12, [x23]
 2a4:	085f7d70 	ldxrb	w16, [x11]
 2a8:	085ffc22 	ldaxrb	w2, [x1]
 2ac:	089ffede 	stlrb	w30, [x22]
 2b0:	08dffdd4 	ldarb	w20, [x14]
 2b4:	c87f3c18 	ldxp	x24, x15, [x0]
 2b8:	c87fa981 	ldaxp	x1, x10, [x12]
 2bc:	c82369a0 	stxp	w3, x0, x26, [x13]
 2c0:	c8209b8a 	stlxp	w0, x10, x6, [x28]
 2c4:	887f5622 	ldxp	w2, w21, [x17]
 2c8:	887f8d8c 	ldaxp	w12, w3, [x12]
 2cc:	88251e66 	stxp	w5, w6, w7, [x19]
 2d0:	883ba774 	stlxp	w27, w20, w9, [x27]
 2d4:	f81810a9 	str	x9, [x5,#-127]
 2d8:	b80032f3 	str	w19, [x23,#3]
 2dc:	390004ce 	strb	w14, [x6,#1]
 2e0:	781df213 	strh	w19, [x16,#-33]
 2e4:	f8561207 	ldr	x7, [x16,#-159]
 2e8:	b9400b79 	ldr	w25, [x27,#8]
 2ec:	394031c3 	ldrb	w3, [x14,#12]
 2f0:	785ea0ec 	ldrh	w12, [x7,#-22]
 2f4:	389e9204 	ldrsb	x4, [x16,#-23]
 2f8:	788071d4 	ldrsh	x20, [x14,#7]
 2fc:	79c00612 	ldrsh	w18, [x16,#2]
 300:	b883b004 	ldrsw	x4, [x0,#59]
 304:	fc5773cc 	ldr	d12, [x30,#-137]
 308:	bc5b22bd 	ldr	s29, [x21,#-78]
 30c:	fc0373a6 	str	d6, [x29,#55]
 310:	bc18215c 	str	s28, [x10,#-126]
 314:	f81fef5a 	str	x26, [x26,#-2]!
 318:	b819ed62 	str	w2, [x11,#-98]!
 31c:	381ebe54 	strb	w20, [x18,#-21]!
 320:	781f5ca1 	strh	w1, [x5,#-11]!
 324:	f8591ec8 	ldr	x8, [x22,#-111]!
 328:	b841ec06 	ldr	w6, [x0,#30]!
 32c:	3840fe97 	ldrb	w23, [x20,#15]!
 330:	785e3eb1 	ldrh	w17, [x21,#-29]!
 334:	389ede8c 	ldrsb	x12, [x20,#-19]!
 338:	789cdda7 	ldrsh	x7, [x13,#-51]!
 33c:	78dd9d7a 	ldrsh	w26, [x11,#-39]!
 340:	b8807ea8 	ldrsw	x8, [x21,#7]!
 344:	fc426cb0 	ldr	d16, [x5,#38]!
 348:	bc40fcd9 	ldr	s25, [x6,#15]!
 34c:	fc1d7c95 	str	d21, [x4,#-41]!
 350:	bc1f3c3c 	str	s28, [x1,#-13]!
 354:	f801e45b 	str	x27, [x2],#30
 358:	b81f4463 	str	w3, [x3],#-12
 35c:	381f14ab 	strb	w11, [x5],#-15
 360:	7800977d 	strh	w29, [x27],#9
 364:	f847d4db 	ldr	x27, [x6],#125
 368:	b85a6664 	ldr	w4, [x19],#-90
 36c:	385fd731 	ldrb	w17, [x25],#-3
 370:	785fa75a 	ldrh	w26, [x26],#-6
 374:	389fb7d5 	ldrsb	x21, [x30],#-5
 378:	7880f44d 	ldrsh	x13, [x2],#15
 37c:	78dcd570 	ldrsh	w16, [x11],#-51
 380:	b89ec6c4 	ldrsw	x4, [x22],#-20
 384:	fc43e690 	ldr	d16, [x20],#62
 388:	bc5a77dd 	ldr	s29, [x30],#-89
 38c:	fc13e4a1 	str	d1, [x5],#-194
 390:	bc1ab4c4 	str	s4, [x6],#-85
 394:	f83e698a 	str	x10, [x12,x30]
 398:	b82969ab 	str	w11, [x13,x9]
 39c:	383e6a39 	strb	w25, [x17,x30]
 3a0:	78266948 	strh	w8, [x10,x6]
 3a4:	f8616a47 	ldr	x7, [x18,x1]
 3a8:	b87e6881 	ldr	w1, [x4,x30]
 3ac:	386a69c4 	ldrb	w4, [x14,x10]
 3b0:	78786959 	ldrh	w25, [x10,x24]
 3b4:	38b36abd 	ldrsb	x29, [x21,x19]
 3b8:	78b568fe 	ldrsh	x30, [x7,x21]
 3bc:	78f66a2a 	ldrsh	w10, [x17,x22]
 3c0:	b8bc6ac2 	ldrsw	x2, [x22,x28]
 3c4:	fc6b6a58 	ldr	d24, [x18,x11]
 3c8:	bc6468b8 	ldr	s24, [x5,x4]
 3cc:	fc306ad4 	str	d20, [x22,x16]
 3d0:	bc2b6abd 	str	s29, [x21,x11]
 3d4:	f91c8523 	str	x3, [x9,#14600]
 3d8:	b91ae4bc 	str	w28, [x5,#6884]
 3dc:	391f819a 	strb	w26, [x12,#2016]
 3e0:	791a211d 	strh	w29, [x8,#3344]
 3e4:	f959b59e 	ldr	x30, [x12,#13160]
 3e8:	b95a8334 	ldr	w20, [x25,#6784]
 3ec:	395b1d90 	ldrb	w16, [x12,#1735]
 3f0:	7958e7b9 	ldrh	w25, [x29,#3186]
 3f4:	39987f47 	ldrsb	x7, [x26,#1567]
 3f8:	799da4b9 	ldrsh	x25, [x5,#3794]
 3fc:	79dde1b6 	ldrsh	w22, [x13,#3824]
 400:	b99bbb34 	ldrsw	x20, [x25,#7096]
 404:	fd5f451b 	ldr	d27, [x8,#16008]
 408:	bd5ee1e6 	ldr	s6, [x15,#7904]
 40c:	fd1b1ea5 	str	d5, [x21,#13880]
 410:	bd186eb3 	str	s19, [x21,#6252]
 414:	5800000e 	ldr	x14, 414 <back+0x414>
 418:	18ffdf5e 	ldr	w30, 0 <back>
 41c:	f8825000 	prfm	pldl1keep, [x0,#37]
 420:	d8000000 	prfm	pldl1keep, 420 <back+0x420>
 424:	f8ab6800 	prfm	pldl1keep, [x0,x11]
 428:	f99d7300 	prfm	pldl1keep, [x24,#15072]
 42c:	1a100136 	adc	w22, w9, w16
 430:	3a1301d8 	adcs	w24, w14, w19
 434:	5a1e030b 	sbc	w11, w24, w30
 438:	7a050221 	sbcs	w1, w17, w5
 43c:	9a0f01cd 	adc	x13, x14, x15
 440:	ba02019b 	adcs	x27, x12, x2
 444:	da1603cb 	sbc	x11, x30, x22
 448:	fa0a018c 	sbcs	x12, x12, x10
 44c:	0b32d37d 	add	w29, w27, w18, sxtw #4
 450:	2b2f2a0a 	adds	w10, w16, w15, uxth #2
 454:	cb360e27 	sub	x7, x17, w22, uxtb #3
 458:	6b378ec8 	subs	w8, w22, w23, sxtb #3
 45c:	8b3ea4d9 	add	x25, x6, w30, sxth #1
 460:	ab276609 	adds	x9, x16, x7, uxtx #1
 464:	cb2e6ccd 	sub	x13, x6, x14, uxtx #3
 468:	eb39a4d6 	subs	x22, x6, w25, sxth #1
 46c:	3a52134d 	ccmn	w26, w18, #0xd, ne
 470:	7a5e7202 	ccmp	w16, w30, #0x2, vc
 474:	ba57b00a 	ccmn	x0, x23, #0xa, lt
 478:	fa41a0cb 	ccmp	x6, x1, #0xb, ge
 47c:	3a485b6e 	ccmn	w27, #0x8, #0xe, pl
 480:	7a5e7acc 	ccmp	w22, #0x1e, #0xc, vc
 484:	ba435945 	ccmn	x10, #0x3, #0x5, pl
 488:	fa5319ec 	ccmp	x15, #0x13, #0xc, ne
 48c:	1a8e52e6 	csel	w6, w23, w14, pl
 490:	1a92c6b5 	csinc	w21, w21, w18, gt
 494:	5a85414a 	csinv	w10, w10, w5, mi
 498:	5a9dc6d2 	csneg	w18, w22, w29, gt
 49c:	9a823014 	csel	x20, x0, x2, cc
 4a0:	9a95970a 	csinc	x10, x24, x21, ls
 4a4:	da999054 	csinv	x20, x2, x25, ls
 4a8:	da8fd6bc 	csneg	x28, x21, x15, le
 4ac:	5ac00379 	rbit	w25, w27
 4b0:	5ac0043e 	rev16	w30, w1
 4b4:	5ac0080e 	rev	w14, w0
 4b8:	5ac0108f 	clz	w15, w4
 4bc:	5ac016cd 	cls	w13, w22
 4c0:	dac0008e 	rbit	x14, x4
 4c4:	dac0062d 	rev16	x13, x17
 4c8:	dac008f8 	rev32	x24, x7
 4cc:	dac00ea1 	rev	x1, x21
 4d0:	dac01275 	clz	x21, x19
 4d4:	dac01792 	cls	x18, x28
 4d8:	1ac308c3 	udiv	w3, w6, w3
 4dc:	1ac20d7d 	sdiv	w29, w11, w2
 4e0:	1acd2135 	lsl	w21, w9, w13
 4e4:	1ad226f1 	lsr	w17, w23, w18
 4e8:	1ade28bb 	asr	w27, w5, w30
 4ec:	1ad12e56 	ror	w22, w18, w17
 4f0:	9add094d 	udiv	x13, x10, x29
 4f4:	9ace0de2 	sdiv	x2, x15, x14
 4f8:	9ac82142 	lsl	x2, x10, x8
 4fc:	9ad8262a 	lsr	x10, x17, x24
 500:	9ad82946 	asr	x6, x10, x24
 504:	9ad72d0b 	ror	x11, x8, x23
 508:	1b0a1dc3 	madd	w3, w14, w10, w7
 50c:	1b0fc539 	msub	w25, w9, w15, w17
 510:	9b040d5e 	madd	x30, x10, x4, x3
 514:	9b1ab5c2 	msub	x2, x14, x26, x13
 518:	9b20518d 	smaddl	x13, w12, w0, x20
 51c:	9b3bb300 	smsubl	x0, w24, w27, x12
 520:	9ba87435 	umaddl	x21, w1, w8, x29
 524:	9bb9b1c1 	umsubl	x1, w14, w25, x12
 528:	1e370aa4 	fmul	s4, s21, s23
 52c:	1e351863 	fdiv	s3, s3, s21
 530:	1e342a94 	fadd	s20, s20, s20
 534:	1e253991 	fsub	s17, s12, s5
 538:	1e370943 	fmul	s3, s10, s23
 53c:	1e6c0901 	fmul	d1, d8, d12
 540:	1e61189c 	fdiv	d28, d4, d1
 544:	1e652b38 	fadd	d24, d25, d5
 548:	1e763923 	fsub	d3, d9, d22
 54c:	1e6e0b7b 	fmul	d27, d27, d14
 550:	1f0d694d 	fmadd	s13, s10, s13, s26
 554:	1f1d9f6c 	fmsub	s12, s27, s29, s7
 558:	1f216837 	fnmadd	s23, s1, s1, s26
 55c:	1f341508 	fnmadd	s8, s8, s20, s5
 560:	1f5b6f4e 	fmadd	d14, d26, d27, d27
 564:	1f5cd0e3 	fmsub	d3, d7, d28, d20
 568:	1f6f4204 	fnmadd	d4, d16, d15, d16
 56c:	1f634f3d 	fnmadd	d29, d25, d3, d19
 570:	1e2042f2 	fmov	s18, s23
 574:	1e20c0bb 	fabs	s27, s5
 578:	1e2140de 	fneg	s30, s6
 57c:	1e21c270 	fsqrt	s16, s19
 580:	1e22c39e 	fcvt	d30, s28
 584:	1e604138 	fmov	d24, d9
 588:	1e60c248 	fabs	d8, d18
 58c:	1e614184 	fneg	d4, d12
 590:	1e61c07c 	fsqrt	d28, d3
 594:	1e62409a 	fcvt	s26, d4
 598:	1e3802a4 	fcvtzs	w4, s21
 59c:	9e380257 	fcvtzs	x23, s18
 5a0:	1e7802d1 	fcvtzs	w17, d22
 5a4:	9e78024b 	fcvtzs	x11, d18
 5a8:	1e2200bd 	scvtf	s29, w5
 5ac:	9e220186 	scvtf	s6, x12
 5b0:	1e6201f2 	scvtf	d18, w15
 5b4:	9e620090 	scvtf	d16, x4
 5b8:	1e26029c 	fmov	w28, s20
 5bc:	9e6601c6 	fmov	x6, d14
 5c0:	1e270013 	fmov	s19, w0
 5c4:	9e670267 	fmov	d7, x19
 5c8:	1e3d2380 	fcmp	s28, s29
 5cc:	1e7c2020 	fcmp	d1, d28
 5d0:	1e2022e8 	fcmp	s23, #0.0
 5d4:	1e6021a8 	fcmp	d13, #0.0
 */

  static const unsigned int insns[] =
  {
    0x8b8397af,     0xcb1e8b15,     0xab92cdd6,     0xeb9e48dd,
    0x0b537e63,     0x4b51490c,     0x2b860061,     0x6b4d2421,
    0x8a88fe4f,     0xaa5388d9,     0xca98ac9a,     0xea836502,
    0x0a4507cb,     0x2a1d4d99,     0x4a1919db,     0x6a8c65fb,
    0x8a7a6729,     0xaa7b4ca1,     0xca394875,     0xea22021d,
    0x0a3b7878,     0x2a2901e5,     0x4a6011b0,     0x6a356552,
    0x110bf089,     0x310ce4ee,     0x510fda70,     0x71068d30,
    0x9104e8b8,     0xb106dd72,     0xd102d69e,     0xf10f397e,
    0x12163889,     0x320e656a,     0x521251ec,     0x720001fe,
    0x924d85d1,     0xb252073d,     0xd276b050,     0xf2494a13,
    0x14000000,     0x17ffffd7,     0x1400014c,     0x94000000,
    0x97ffffd4,     0x94000149,     0x3400001c,     0x34fffa3c,
    0x340028dc,     0x35000002,     0x35fff9c2,     0x35002862,
    0xb4000015,     0xb4fff975,     0xb4002815,     0xb5000011,
    0xb5fff911,     0xb50027b1,     0x1000001e,     0x10fff8be,
    0x1000275e,     0x9000000a,     0x3600001a,     0x3607f83a,
    0x360026da,     0x3750000b,     0x3757f7cb,     0x3750266b,
    0x12aa7ee6,     0x528ae195,     0x72870c6c,     0x92aceee8,
    0xd2aa0697,     0xf2cbff5b,     0x935c3332,     0x330845fb,
    0x530524d1,     0x9341026f,     0xb34f6645,     0xd35f5ec1,
    0x13964baf,     0x93cf55f4,     0x54000000,     0x54fff5a0,
    0x54002440,     0x54000001,     0x54fff541,     0x540023e1,
    0x54000002,     0x54fff4e2,     0x54002382,     0x54000002,
    0x54fff482,     0x54002322,     0x54000003,     0x54fff423,
    0x540022c3,     0x54000003,     0x54fff3c3,     0x54002263,
    0x54000004,     0x54fff364,     0x54002204,     0x54000005,
    0x54fff305,     0x540021a5,     0x54000006,     0x54fff2a6,
    0x54002146,     0x54000007,     0x54fff247,     0x540020e7,
    0x54000008,     0x54fff1e8,     0x54002088,     0x54000009,
    0x54fff189,     0x54002029,     0x5400000a,     0x54fff12a,
    0x54001fca,     0x5400000b,     0x54fff0cb,     0x54001f6b,
    0x5400000c,     0x54fff06c,     0x54001f0c,     0x5400000d,
    0x54fff00d,     0x54001ead,     0x5400000e,     0x54ffefae,
    0x54001e4e,     0x5400000f,     0x54ffef4f,     0x54001def,
    0xd404bf81,     0xd409a6a2,     0xd406da23,     0xd4299300,
    0xd4420cc0,     0xd503201f,     0xd69f03e0,     0xd6bf03e0,
    0xd5033fdf,     0xd5033b9f,     0xd50335bf,     0xd61f01a0,
    0xd63f0040,     0xc81c7c70,     0xc818fc2b,     0xc85f7c47,
    0xc85ffe5e,     0xc89ffdec,     0xc8dffccb,     0x880e7d16,
    0x881afe35,     0x885f7c7c,     0x885ffc17,     0x889ffcc2,
    0x88dffe44,     0x480b7eb6,     0x480ffcf9,     0x485f7c1a,
    0x485fff67,     0x489ffe8c,     0x48dfff11,     0x08107e73,
    0x081cfeec,     0x085f7d70,     0x085ffc22,     0x089ffede,
    0x08dffdd4,     0xc87f3c18,     0xc87fa981,     0xc82369a0,
    0xc8209b8a,     0x887f5622,     0x887f8d8c,     0x88251e66,
    0x883ba774,     0xf81810a9,     0xb80032f3,     0x390004ce,
    0x781df213,     0xf8561207,     0xb9400b79,     0x394031c3,
    0x785ea0ec,     0x389e9204,     0x788071d4,     0x79c00612,
    0xb883b004,     0xfc5773cc,     0xbc5b22bd,     0xfc0373a6,
    0xbc18215c,     0xf81fef5a,     0xb819ed62,     0x381ebe54,
    0x781f5ca1,     0xf8591ec8,     0xb841ec06,     0x3840fe97,
    0x785e3eb1,     0x389ede8c,     0x789cdda7,     0x78dd9d7a,
    0xb8807ea8,     0xfc426cb0,     0xbc40fcd9,     0xfc1d7c95,
    0xbc1f3c3c,     0xf801e45b,     0xb81f4463,     0x381f14ab,
    0x7800977d,     0xf847d4db,     0xb85a6664,     0x385fd731,
    0x785fa75a,     0x389fb7d5,     0x7880f44d,     0x78dcd570,
    0xb89ec6c4,     0xfc43e690,     0xbc5a77dd,     0xfc13e4a1,
    0xbc1ab4c4,     0xf83e698a,     0xb82969ab,     0x383e6a39,
    0x78266948,     0xf8616a47,     0xb87e6881,     0x386a69c4,
    0x78786959,     0x38b36abd,     0x78b568fe,     0x78f66a2a,
    0xb8bc6ac2,     0xfc6b6a58,     0xbc6468b8,     0xfc306ad4,
    0xbc2b6abd,     0xf91c8523,     0xb91ae4bc,     0x391f819a,
    0x791a211d,     0xf959b59e,     0xb95a8334,     0x395b1d90,
    0x7958e7b9,     0x39987f47,     0x799da4b9,     0x79dde1b6,
    0xb99bbb34,     0xfd5f451b,     0xbd5ee1e6,     0xfd1b1ea5,
    0xbd186eb3,     0x5800000e,     0x18ffdf5e,     0xf8825000,
    0xd8000000,     0xf8ab6800,     0xf99d7300,     0x1a100136,
    0x3a1301d8,     0x5a1e030b,     0x7a050221,     0x9a0f01cd,
    0xba02019b,     0xda1603cb,     0xfa0a018c,     0x0b32d37d,
    0x2b2f2a0a,     0xcb360e27,     0x6b378ec8,     0x8b3ea4d9,
    0xab276609,     0xcb2e6ccd,     0xeb39a4d6,     0x3a52134d,
    0x7a5e7202,     0xba57b00a,     0xfa41a0cb,     0x3a485b6e,
    0x7a5e7acc,     0xba435945,     0xfa5319ec,     0x1a8e52e6,
    0x1a92c6b5,     0x5a85414a,     0x5a9dc6d2,     0x9a823014,
    0x9a95970a,     0xda999054,     0xda8fd6bc,     0x5ac00379,
    0x5ac0043e,     0x5ac0080e,     0x5ac0108f,     0x5ac016cd,
    0xdac0008e,     0xdac0062d,     0xdac008f8,     0xdac00ea1,
    0xdac01275,     0xdac01792,     0x1ac308c3,     0x1ac20d7d,
    0x1acd2135,     0x1ad226f1,     0x1ade28bb,     0x1ad12e56,
    0x9add094d,     0x9ace0de2,     0x9ac82142,     0x9ad8262a,
    0x9ad82946,     0x9ad72d0b,     0x1b0a1dc3,     0x1b0fc539,
    0x9b040d5e,     0x9b1ab5c2,     0x9b20518d,     0x9b3bb300,
    0x9ba87435,     0x9bb9b1c1,     0x1e370aa4,     0x1e351863,
    0x1e342a94,     0x1e253991,     0x1e370943,     0x1e6c0901,
    0x1e61189c,     0x1e652b38,     0x1e763923,     0x1e6e0b7b,
    0x1f0d694d,     0x1f1d9f6c,     0x1f216837,     0x1f341508,
    0x1f5b6f4e,     0x1f5cd0e3,     0x1f6f4204,     0x1f634f3d,
    0x1e2042f2,     0x1e20c0bb,     0x1e2140de,     0x1e21c270,
    0x1e22c39e,     0x1e604138,     0x1e60c248,     0x1e614184,
    0x1e61c07c,     0x1e62409a,     0x1e3802a4,     0x9e380257,
    0x1e7802d1,     0x9e78024b,     0x1e2200bd,     0x9e220186,
    0x1e6201f2,     0x9e620090,     0x1e26029c,     0x9e6601c6,
    0x1e270013,     0x9e670267,     0x1e3d2380,     0x1e7c2020,
    0x1e2022e8,     0x1e6021a8, 
  };
// END  Generated code -- do not edit
// END  Generated code -- do not edit

  {
    bool ok = true;
    unsigned int *insns1 = (unsigned int *)entry;
    for (unsigned int i = 0; i < sizeof insns / sizeof insns[0]; i++) {
      if (insns[i] != insns1[i]) {
	ok = false;
	printf("Ours:\n");
	Disassembler::decode((address)&insns1[i], (address)&insns1[i+1]);
	printf("Theirs:\n");
	Disassembler::decode((address)&insns[i], (address)&insns[i+1]);
	printf("\n");
      }
    }
    assert(ok, "Assembler smoke test failed");
  }
#endif // ASSERT

#ifdef PRODUCT
#define BLOCK_COMMENT(str) /* nothing */
#else
#define BLOCK_COMMENT(str) __ block_comment(str)
#endif

#define BIND(label) bind(label); BLOCK_COMMENT(#label ":")

  {
    Label l, loop, empty;
    address a = __ pc();
    __ adr(r3, l);
    __ adrp(r4, l);
    __ bl(empty);
    __ movz(r0, 0);
    __ BIND(loop);
    __ subs(sp, r0, 10);
    __ br(Assembler::NE, l);
    __ add(r0, r0, 1u);
    __ adr(r3, loop);
    __ br(Assembler::AL, loop);
    __ BIND(l);
    __ BIND(empty);
    __ ret(r_lr);
    Disassembler::decode(a, __ pc());
    printf("\n");
  }
}


#define gas_assert(ARG1) assert(ARG1, #ARG1)

// ------------- Stolen from binutils begin -------------------------------------

/* Build the accepted values for immediate logical SIMD instructions.
 *
 * The valid encodings of the immediate value are:
 *   opc<0> j:jjjjj  i:iii:ii  SIMD size  R             S
 *   1      ssssss   rrrrrr       64      UInt(rrrrrr)  UInt(ssssss)
 *   0      0sssss   0rrrrr       32      UInt(rrrrr)   UInt(sssss)
 *   0      10ssss   00rrrr       16      UInt(rrrr)    UInt(ssss)
 *   0      110sss   000rrr       8       UInt(rrr)     UInt(sss)
 *   0      1110ss   0000rr       4       UInt(rr)      UInt(ss)
 *   0      11110s   00000r       2       UInt(r)       UInt(s)
 *   other combinations                   UNPREDICTABLE
 *
 * Let's call E the SIMD size.
 *
 * The immediate value is: S+1 bits '1' rotated to the right by R.
 *
 * The total of valid encodings is 64^2 + 32^2 + ... + 2^2 = 5460.
 *
 * This means we have the following number of distinct values:
 *   - for S = E - 1, all values of R generate a word full of '1'
 *      so we have 2 + 4 + ... + 64 = 126 ways of encoding 0xf...f
 *   - for S != E - 1, all value are obviously distinct
 *      so we have #{ for all E: (E - 1) * R (where R = E) } values
 *        = 64*63 + 32*31 + ... + 2*1 = 5334
 *   - it is obvious that for two different values of E, if S != E - 1
 *      then we can't generate the same value.
 * So the total number of distinct values is 5334 + 1 = 5335 (out of
 * a total of 5460 valid encodings).
 */
#define TOTAL_IMM_NB  5334

typedef struct {
  uint64_t imm;
  uint32_t encoding;
} simd_imm_encoding_v2;

static simd_imm_encoding_v2 simd_immediates_v2[TOTAL_IMM_NB];

static int
simd_imm_encoding_cmp_v2(const void *i1, const void *i2)
{
  const simd_imm_encoding_v2 *imm1 = (const simd_imm_encoding_v2 *)i1;
  const simd_imm_encoding_v2 *imm2 = (const simd_imm_encoding_v2 *)i2;

  if (imm1->imm < imm2->imm)
    return -1;
  if (imm1->imm > imm2->imm)
    return +1;
  return 0;
}

/* immediate bitfield encoding
 * imm13<12> imm13<5:0> imm13<11:6> SIMD size R      S
 * 1         ssssss     rrrrrr      64        rrrrrr ssssss
 * 0         0sssss     0rrrrr      32        rrrrr  sssss
 * 0         10ssss     00rrrr      16        rrrr   ssss
 * 0         110sss     000rrr      8         rrr    sss
 * 0         1110ss     0000rr      4         rr     ss
 * 0         11110s     00000r      2         r      s
 */
static inline int encode_immediate_bitfield(int is64, uint32_t s, uint32_t r)
{
  return (is64 << 12) | (r << 6) | s;
}

static void
build_immediate_table_v2(void) __attribute__ ((constructor));

static void
build_immediate_table_v2(void)
{
  uint32_t log_e, e, s, r, s_mask;
  uint64_t mask, imm;
  int nb_imms;
  int is64;

  nb_imms = 0;
  for (log_e = 1; log_e <= 6; log_e++) {
    e = 1u << log_e;
    if (log_e == 6) {
      is64 = 1;
      mask = 0xffffffffffffffffull;
      s_mask = 0;
    } else {
      is64 = 0;
      mask = (1ull << e) - 1;
      /* log_e  s_mask
       *  1     ((1 << 4) - 1) << 2 = 111100
       *  2     ((1 << 3) - 1) << 3 = 111000
       *  3     ((1 << 2) - 1) << 4 = 110000
       *  4     ((1 << 1) - 1) << 5 = 100000
       *  5     ((1 << 0) - 1) << 6 = 000000
       */
      s_mask = ((1u << (5 - log_e)) - 1) << (log_e + 1);
    }
    for (s = 0; s < e - 1; s++) {
      for (r = 0; r < e; r++) {
        /* s+1 consecutive bits to 1 (s < 63) */
        imm = (1ull << (s + 1)) - 1;
        /* rotate right by r */
        if (r != 0)
          imm = (imm >> r) | ((imm << (e - r)) & mask);
        /* replicate the constant depending on SIMD size */
        switch (log_e) {
        case 1: imm = (imm <<  2) | imm;
        case 2: imm = (imm <<  4) | imm;
        case 3: imm = (imm <<  8) | imm;
        case 4: imm = (imm << 16) | imm;
        case 5: imm = (imm << 32) | imm;
        case 6:
          break;
        default:
          abort ();
        }
        simd_immediates_v2[nb_imms].imm = imm;
        simd_immediates_v2[nb_imms].encoding =
          encode_immediate_bitfield(is64, s | s_mask, r);
        nb_imms++;
      }
    }
  }
  gas_assert(nb_imms == TOTAL_IMM_NB);
  qsort(simd_immediates_v2, nb_imms,
        sizeof(simd_immediates_v2[0]), simd_imm_encoding_cmp_v2);
}

/* Create a valid encoding for imm.  Returns ffffffff since it's an invalid
   encoding.  */
uint32_t
asm_util::encode_immediate_v2(int is32, uint64_t imm)
{
  simd_imm_encoding_v2 imm_enc;
  const simd_imm_encoding_v2 *imm_encoding;

  if (is32) {
    /* Allow all zeros or all ones in top 32-bits, so that
       constant expressions like ~1 are permitted. */
    if (imm >> 32 != 0 && imm >> 32 != 0xffffffff)
      return 0xffffffff;
    /* Replicate the 32 lower bits to the 32 upper bits.  */
    imm &= 0xffffffff;
    imm |= imm << 32;
  }

  imm_enc.imm = imm;
  imm_encoding = (const simd_imm_encoding_v2 *)
    bsearch(&imm_enc, simd_immediates_v2, TOTAL_IMM_NB,
            sizeof(simd_immediates_v2[0]), simd_imm_encoding_cmp_v2);
  if (imm_encoding == NULL)
    return 0xffffffff;
  return imm_encoding->encoding;
}

// ------------- Stolen from binutils end -------------------------------------

Instruction_aarch64::~Instruction_aarch64() {
  assem->emit();
}

void Assembler::br(Condition cc, Label &L) {
  if (L.is_bound()) {
    br(cc, target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    br(cc, pc());
  }
}

void Assembler::wrap_label(Label &L,
				 Assembler::uncond_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    (this->*insn)(pc());
  }
}

void Assembler::wrap_label(Register r, Label &L,
				 compare_and_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(r, target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    (this->*insn)(r, pc());
  }
}

void Assembler::wrap_label(Register r, int bitpos, Label &L,
				 test_and_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(r, bitpos, target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    (this->*insn)(r, bitpos, pc());
  }
}

void Assembler::wrap_label(Label &L, int prfop, prefetch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(target(L), prfop);
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    (this->*insn)(pc(), prfop);
  }
}


void MacroAssembler::pd_patch_instruction(address branch, address target) {
  long offset = (target - branch) >> 2;
  unsigned insn = *(unsigned*)branch;
  if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {
    // Load register (literal)
    Instruction_aarch64::spatch(branch, 23, 5, offset);
  } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
    // Unconditional branch (immediate)
    Instruction_aarch64::spatch(branch, 25, 0, offset);
  } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
    // Conditional branch (immediate)
    Instruction_aarch64::spatch(branch, 23, 5, offset);
  } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
    // Compare & branch (immediate)
    Instruction_aarch64::spatch(branch, 23, 5, offset);
  } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
    // Test & branch (immediate)
    Instruction_aarch64::spatch(branch, 18, 5, offset);
  } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
    // PC-rel. addressing
    offset = target-branch;
    int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;
    offset >>= shift;
    int offset_lo = offset & 3;
    offset >>= 2;
    Instruction_aarch64::spatch(branch, 18, 5, offset);
    Instruction_aarch64::spatch(branch, 30, 29, offset_lo);
  } else {
    abort();
  }
}

bool Assembler::operand_valid_for_logical_immdiate(int is32, uint64_t imm) {
  return encode_immediate_v2(is32, imm) != 0xffffffff;
}

int AbstractAssembler::code_fill_byte() { Unimplemented(); }

// added to make this compile

REGISTER_DEFINITION(Register, noreg);

void MacroAssembler::call_VM_base(Register oop_result,
				  Register java_thread,
				  Register last_java_sp,
				  address  entry_point,
				  int      number_of_arguments,
				  bool     check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             bool check_exceptions) { Unimplemented(); }


void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             Register arg_3,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
			     Register last_java_sp,
			     address entry_point,
			     int number_of_arguments,
			     bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
			     bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             Register arg_3,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::check_and_handle_earlyret(Register java_thread) {Unimplemented(); }

void MacroAssembler::align(int modulus) { Unimplemented();}

void MacroAssembler::check_and_handle_popframe(Register java_thread) { Unimplemented(); }

RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
                                                      Register tmp,
                                                      int offset) { Unimplemented(); return RegisterOrConstant(r0); }

void MacroAssembler::verify_oop(Register reg, const char* s) { Unimplemented(); }

void MacroAssembler::stop(const char* msg) { Unimplemented(); }

void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) { Unimplemented(); }

void MacroAssembler::null_check(Register reg, int offset) { Unimplemented(); }

// routine to generate an x86 prolog for a stub function which
// bootstraps into the generated ARM code which directly follows the
// stub
//
// the argument encodes the number of general and fp registers
// passed by the caller and the callng convention (currently just
// the number of general registers and assumes C argument passing)

extern "C" {
int aarch64_stub_prolog_size();
void aarch64_stub_prolog();
void setup_arm_sim(void *sp, int calltype);
}

void MacroAssembler::c_stub_prolog(u_int64_t calltype)
{
  // the addresses for the x86 to ARM entry code we need to use
  address start = pc();
  // printf("start = %lx\n", start);
  int byteCount =  aarch64_stub_prolog_size();
  // printf("byteCount = %x\n", byteCount);
  int instructionCount = (byteCount + 3)/ 4;
  // printf("instructionCount = %x\n", instructionCount);
  for (int i = 0; i < instructionCount; i++) {
    nop();
  }

  memcpy(start, (void*)aarch64_stub_prolog, byteCount);

  // write the address of the setup routine and the call format at the
  // end of into the copied code
  u_int64_t *patch_end = (u_int64_t *)(start + byteCount);
  patch_end[-2] = (u_int64_t)setup_arm_sim;
  patch_end[-1] = calltype;
}
