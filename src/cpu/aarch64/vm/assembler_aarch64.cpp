/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

#undef TARGET_ARCH_x86
#define TARGET_ARCH_AARCH64
#define CPU_X86_VM_REGISTER_X86_HPP

#include <stdio.h>
#include <sys/types.h>

#include "precompiled.hpp"
// #include "assembler_aarch64.inline.hpp"
#include "asm/assembler.hpp"
#include "assembler_aarch64.hpp"

#include "compiler/disassembler.hpp"

// #include "gc_interface/collectedHeap.inline.hpp"
// #include "interpreter/interpreter.hpp"
// #include "memory/cardTableModRefBS.hpp"
// #include "memory/resourceArea.hpp"
// #include "prims/methodHandles.hpp"
// #include "runtime/biasedLocking.hpp"
// #include "runtime/interfaceSupport.hpp"
// #include "runtime/objectMonitor.hpp"
// #include "runtime/os.hpp"
// #include "runtime/sharedRuntime.hpp"
// #include "runtime/stubRoutines.hpp"
// #ifndef SERIALGC
// #include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
// #include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
// #include "gc_implementation/g1/heapRegion.hpp"
// #endif


extern "C" void entry(CodeBuffer *cb);

#define __ _masm.

void entry(CodeBuffer *cb) {
  Assembler _masm(cb);
  address entry = __ pc();

  // Smoke test for assembler

#if ASSERT
// BEGIN  Generated code -- do not edit
// Generated by aarch64-asmtest.py

// ArithOp
    __ add(r13, r21, r30, Assembler::lsl, 41);    //	add	x13, x21, x30, lsl #41
    __ sub(r6, r16, r22, Assembler::lsr, 47);     //	sub	x6, x16, x22, lsr #47
    __ adds(r4, r19, r9, Assembler::lsl, 25);     //	adds	x4, x19, x9, lsl #25
    __ subs(r0, r23, r1, Assembler::asr, 5);      //	subs	x0, x23, x1, asr #5
    __ addw(r1, r22, r0, Assembler::lsl, 15);     //	add	w1, w22, w0, lsl #15
    __ subw(r20, r27, r13, Assembler::lsr, 18);   //	sub	w20, w27, w13, lsr #18
    __ addsw(r6, r12, r28, Assembler::lsl, 3);    //	adds	w6, w12, w28, lsl #3
    __ subsw(r9, r0, r12, Assembler::lsl, 21);    //	subs	w9, w0, w12, lsl #21
    __ andr(r22, r26, r27, Assembler::lsl, 56);   //	and	x22, x26, x27, lsl #56
    __ orr(r20, r23, r21, Assembler::lsr, 62);    //	orr	x20, x23, x21, lsr #62
    __ eor(r3, r5, r8, Assembler::lsr, 16);       //	eor	x3, x5, x8, lsr #16
    __ ands(r0, r12, r4, Assembler::lsr, 17);     //	ands	x0, x12, x4, lsr #17
    __ andw(r0, r20, r1, Assembler::lsl, 1);      //	and	w0, w20, w1, lsl #1
    __ orrw(r29, r22, r8, Assembler::asr, 12);    //	orr	w29, w22, w8, asr #12
    __ eorw(r27, r28, r25, Assembler::asr, 4);    //	eor	w27, w28, w25, asr #4
    __ andsw(r10, r6, r23, Assembler::lsl, 23);   //	ands	w10, w6, w23, lsl #23
    __ bic(r26, r22, r25, Assembler::lsr, 42);    //	bic	x26, x22, x25, lsr #42
    __ orn(r27, r2, r1, Assembler::asr, 40);      //	orn	x27, x2, x1, asr #40
    __ eon(r7, r3, r26, Assembler::lsr, 48);      //	eon	x7, x3, x26, lsr #48
    __ bics(r23, r19, r24, Assembler::lsl, 39);   //	bics	x23, x19, x24, lsl #39
    __ bicw(r26, r22, r10, Assembler::lsl, 23);   //	bic	w26, w22, w10, lsl #23
    __ ornw(r21, r20, r24, Assembler::asr, 7);    //	orn	w21, w20, w24, asr #7
    __ eonw(r7, r20, r20, Assembler::lsr, 27);    //	eon	w7, w20, w20, lsr #27
    __ bicsw(r17, r8, r30, Assembler::asr, 0);    //	bics	w17, w8, w30, asr #0

// AddSubImmOp
    __ addw(r26, r16, 204u);                      //	add	w26, w16, #204
    __ addsw(r17, r27, 611u);                     //	adds	w17, w27, #611
    __ subw(r19, r11, 405u);                      //	sub	w19, w11, #405
    __ subsw(r20, r13, 723u);                     //	subs	w20, w13, #723
    __ add(r27, r19, 628u);                       //	add	x27, x19, #628
    __ adds(r11, r17, 858u);                      //	adds	x11, x17, #858
    __ sub(r1, r7, 295u);                         //	sub	x1, x7, #295
    __ subs(r18, r29, 637u);                      //	subs	x18, x29, #637

// LogicalImmOp
    __ andw(r20, r0, 4294950919ul);               //	and	w20, w0, #0xffffc007
    __ orrw(r14, r27, 3233857728ul);              //	orr	w14, w27, #0xc0c0c0c0
    __ eorw(r14, r22, 4294459391ul);              //	eor	w14, w22, #0xfff83fff
    __ andsw(r16, r27, 536870910ul);              //	ands	w16, w27, #0x1ffffffe
    __ andr(r9, r23, 18014398509481728ul);        //	and	x9, x23, #0x3fffffffffff00
    __ orr(r5, r6, 18446744073705357315ul);       //	orr	x5, x6, #0xffffffffffc00003
    __ eor(r5, r9, 4160749568ul);                 //	eor	x5, x9, #0xf8000000
    __ ands(r4, r21, 16140901064495923199ul);     //	ands	x4, x21, #0xe00000000000ffff

// AbsOp
    __ b(__ pc());                                //	b	.
    __ bl(__ pc());                               //	bl	.

// RegAndAbsOp
    __ cbzw(r27, __ pc());                        //	cbz	w27, .
    __ cbnzw(r7, __ pc());                        //	cbnz	w7, .
    __ cbz(r25, __ pc());                         //	cbz	x25, .
    __ cbnz(r12, __ pc());                        //	cbnz	x12, .
    __ adr(r23, __ pc());                         //	adr	x23, .
    __ adrp(r19, __ pc());                        //	adrp	x19, .

// RegImmAbsOp
    __ tbz(r20, 1, __ pc());                      //	tbz	x20, #1, .
    __ tbnz(r23, 12, __ pc());                    //	tbnz	x23, #12, .

// MoveWideImmOp
    __ movnw(r12, 24949, 0);                      //	movn	w12, #24949, lsl 0
    __ movzw(r0, 18470, 16);                      //	movz	w0, #18470, lsl 16
    __ movkw(r4, 2208, 0);                        //	movk	w4, #2208, lsl 0
    __ movn(r1, 27001, 48);                       //	movn	x1, #27001, lsl 48
    __ movz(r2, 17677, 32);                       //	movz	x2, #17677, lsl 32
    __ movk(r4, 26318, 16);                       //	movk	x4, #26318, lsl 16

// BitfieldOp
    __ sbfm(r7, r3, 7, 28);                       //	sbfm	x7, x3, #7, #28
    __ bfmw(r3, r24, 17, 1);                      //	bfm	w3, w24, #17, #1
    __ ubfmw(r10, r27, 16, 30);                   //	ubfm	w10, w27, #16, #30
    __ sbfm(r17, r28, 29, 4);                     //	sbfm	x17, x28, #29, #4
    __ bfm(r18, r23, 22, 18);                     //	bfm	x18, x23, #22, #18
    __ ubfm(r15, r4, 5, 15);                      //	ubfm	x15, x4, #5, #15

// ExtractOp
    __ extrw(r4, r16, r3, 18);                    //	extr	w4, w16, w3, #18
    __ extr(r22, r18, r20, 23);                   //	extr	x22, x18, x20, #23

// CondBranchOp
    __ beq(__ pc());                              //	b.eq	.
    __ bne(__ pc());                              //	b.ne	.
    __ bhs(__ pc());                              //	b.hs	.
    __ bcs(__ pc());                              //	b.cs	.
    __ blo(__ pc());                              //	b.lo	.
    __ bcc(__ pc());                              //	b.cc	.
    __ bmi(__ pc());                              //	b.mi	.
    __ bpl(__ pc());                              //	b.pl	.
    __ bvs(__ pc());                              //	b.vs	.
    __ bvc(__ pc());                              //	b.vc	.
    __ bhi(__ pc());                              //	b.hi	.
    __ bls(__ pc());                              //	b.ls	.
    __ bge(__ pc());                              //	b.ge	.
    __ blt(__ pc());                              //	b.lt	.
    __ bgt(__ pc());                              //	b.gt	.
    __ ble(__ pc());                              //	b.le	.
    __ bal(__ pc());                              //	b.al	.
    __ bnv(__ pc());                              //	b.nv	.

// ImmOp
    __ svc(15350);                                //	svc	#15350
    __ hvc(19924);                                //	hvc	#19924
    __ smc(4328);                                 //	smc	#4328
    __ brk(23864);                                //	brk	#23864
    __ hlt(7194);                                 //	hlt	#7194

// Op
    __ nop();                                     //	nop	
    __ eret();                                    //	eret	
    __ drps();                                    //	drps	
    __ isb();                                     //	isb	

// SystemOp
    __ dsb(Assembler::NSH);                       //	dsb	NSH
    __ dmb(Assembler::ISH);                       //	dmb	ISH

// OneRegOp
    __ br(r20);                                   //	br	x20
    __ blr(r21);                                  //	blr	x21

// LoadStoreExclusiveOp
    __ stxr(r25, r20, r9);                        //	stxr	w25, x20, [x9]
    __ stlxr(r14, r12, r24);                      //	stlxr	w14, x12, [x24]
    __ ldxr(r29, r0);                             //	ldxr	x29, [x0]
    __ ldaxr(r7, r1);                             //	ldaxr	x7, [x1]
    __ stlr(r11, r29);                            //	stlr	x11, [x29]
    __ ldar(r26, r18);                            //	ldar	x26, [x18]

// LoadStoreExclusiveOp
    __ stxrw(r28, r7, r14);                       //	stxr	w28, w7, [x14]
    __ stlxrw(r14, r4, r26);                      //	stlxr	w14, w4, [x26]
    __ ldxrw(r28, r21);                           //	ldxr	w28, [x21]
    __ ldaxrw(r19, r27);                          //	ldaxr	w19, [x27]
    __ stlrw(r12, r7);                            //	stlr	w12, [x7]
    __ ldarw(r27, r6);                            //	ldar	w27, [x6]

// LoadStoreExclusiveOp
    __ stxrh(r2, r24, r17);                       //	stxrh	w2, w24, [x17]
    __ stlxrh(r8, r0, r23);                       //	stlxrh	w8, w0, [x23]
    __ ldxrh(r15, r18);                           //	ldxrh	w15, [x18]
    __ ldaxrh(r7, r4);                            //	ldaxrh	w7, [x4]
    __ stlrh(r9, r3);                             //	stlrh	w9, [x3]
    __ ldarh(r15, r15);                           //	ldarh	w15, [x15]

// LoadStoreExclusiveOp
    __ stxrb(r1, r21, r16);                       //	stxrb	w1, w21, [x16]
    __ stlxrb(r10, r22, r7);                      //	stlxrb	w10, w22, [x7]
    __ ldxrb(r18, r30);                           //	ldxrb	w18, [x30]
    __ ldaxrb(r25, r6);                           //	ldaxrb	w25, [x6]
    __ stlrb(r9, r13);                            //	stlrb	w9, [x13]
    __ ldarb(r22, r18);                           //	ldarb	w22, [x18]

// LoadStoreExclusiveOp
    __ ldxp(r18, r8, r18);                        //	ldxp	x18, x8, [x18]
    __ ldaxp(r23, r10, r5);                       //	ldaxp	x23, x10, [x5]
    __ stxp(r16, r4, r9, r4);                     //	stxp	w16, x4, x9, [x4]
    __ stlxp(r8, r18, r18, r6);                   //	stlxp	w8, x18, x18, [x6]

// LoadStoreExclusiveOp
    __ ldxpw(r16, r1, r19);                       //	ldxp	w16, w1, [x19]
    __ ldaxpw(r26, r23, r20);                     //	ldaxp	w26, w23, [x20]
    __ stxpw(r19, r21, r29, r21);                 //	stxp	w19, w21, w29, [x21]
    __ stlxpw(r13, r23, r0, r29);                 //	stlxp	w13, w23, w0, [x29]

// base_plus_unscaled_offset 
// LoadStoreOp
    __ str(r25, Address(r16, 123));               //	str	x25, [x16, 123]
    __ strw(r28, Address(r15, 38));               //	str	w28, [x15, 38]
    __ strb(r4, Address(r20, -24));               //	strb	w4, [x20, -24]
    __ strh(r15, Address(r9, -32));               //	strh	w15, [x9, -32]
    __ ldr(r24, Address(r13, -217));              //	ldr	x24, [x13, -217]
    __ ldrw(r25, Address(r16, -100));             //	ldr	w25, [x16, -100]
    __ ldrb(r0, Address(r24, -20));               //	ldrb	w0, [x24, -20]
    __ ldrh(r2, Address(r20, -57));               //	ldrh	w2, [x20, -57]
    __ ldrsb(r25, Address(r18, -7));              //	ldrsb	x25, [x18, -7]
    __ ldrsh(r30, Address(r29, -29));             //	ldrsh	x30, [x29, -29]
    __ ldrshw(r1, Address(r8, -58));              //	ldrsh	w1, [x8, -58]
    __ ldrsw(r17, Address(r30, -118));            //	ldrsw	x17, [x30, -118]
    __ ldrd(v7, Address(r0, -233));               //	ldr	d7, [x0, -233]
    __ ldrs(v25, Address(r7, -29));               //	ldr	s25, [x7, -29]
    __ strd(v21, Address(r23, 113));              //	str	d21, [x23, 113]
    __ strs(v27, Address(r3, 37));                //	str	s27, [x3, 37]

// pre 
// LoadStoreOp
    __ str(r23, Address(__ pre(r9, -37)));        //	str	x23, [x9, -37]!
    __ strw(r25, Address(__ pre(r8, -78)));       //	str	w25, [x8, -78]!
    __ strb(r22, Address(__ pre(r20, 2)));        //	strb	w22, [x20, 2]!
    __ strh(r25, Address(__ pre(r25, -25)));      //	strh	w25, [x25, -25]!
    __ ldr(r22, Address(__ pre(r23, -57)));       //	ldr	x22, [x23, -57]!
    __ ldrw(r27, Address(__ pre(r17, 1)));        //	ldr	w27, [x17, 1]!
    __ ldrb(r27, Address(__ pre(r10, 13)));       //	ldrb	w27, [x10, 13]!
    __ ldrh(r28, Address(__ pre(r30, -53)));      //	ldrh	w28, [x30, -53]!
    __ ldrsb(r26, Address(__ pre(r25, -24)));     //	ldrsb	x26, [x25, -24]!
    __ ldrsh(r16, Address(__ pre(r20, -48)));     //	ldrsh	x16, [x20, -48]!
    __ ldrshw(r16, Address(__ pre(r18, -57)));    //	ldrsh	w16, [x18, -57]!
    __ ldrsw(r11, Address(__ pre(r14, -34)));     //	ldrsw	x11, [x14, -34]!
    __ ldrd(v3, Address(__ pre(r21, 74)));        //	ldr	d3, [x21, 74]!
    __ ldrs(v4, Address(__ pre(r22, -51)));       //	ldr	s4, [x22, -51]!
    __ strd(v3, Address(__ pre(r4, -81)));        //	str	d3, [x4, -81]!
    __ strs(v13, Address(__ pre(r13, 29)));       //	str	s13, [x13, 29]!

// post 
// LoadStoreOp
    __ str(r19, Address(__ post(r29, -245)));     //	str	x19, [x29], -245
    __ strw(r28, Address(__ post(r5, -29)));      //	str	w28, [x5], -29
    __ strb(r20, Address(__ post(r17, -22)));     //	strb	w20, [x17], -22
    __ strh(r15, Address(__ post(r16, -2)));      //	strh	w15, [x16], -2
    __ ldr(r27, Address(__ post(r24, -116)));     //	ldr	x27, [x24], -116
    __ ldrw(r11, Address(__ post(r17, -69)));     //	ldr	w11, [x17], -69
    __ ldrb(r16, Address(__ post(r27, -17)));     //	ldrb	w16, [x27], -17
    __ ldrh(r26, Address(__ post(r5, 9)));        //	ldrh	w26, [x5], 9
    __ ldrsb(r5, Address(__ post(r1, 9)));        //	ldrsb	x5, [x1], 9
    __ ldrsh(r9, Address(__ post(r29, 15)));      //	ldrsh	x9, [x29], 15
    __ ldrshw(r22, Address(__ post(r10, -58)));   //	ldrsh	w22, [x10], -58
    __ ldrsw(r26, Address(__ post(r12, -105)));   //	ldrsw	x26, [x12], -105
    __ ldrd(v2, Address(__ post(r27, 84)));       //	ldr	d2, [x27], 84
    __ ldrs(v2, Address(__ post(r22, -89)));      //	ldr	s2, [x22], -89
    __ strd(v15, Address(__ post(r6, -203)));     //	str	d15, [x6], -203
    __ strs(v21, Address(__ post(r13, -128)));    //	str	s21, [x13], -128

// base_plus_reg 
// LoadStoreOp
    __ str(r2, Address(r24, r23));                //	str	x2, [x24, x23]
    __ strw(r19, Address(r26, r5));               //	str	w19, [x26, x5]
    __ strb(r30, Address(r19, r5));               //	strb	w30, [x19, x5]
    __ strh(r20, Address(r19, r25));              //	strh	w20, [x19, x25]
    __ ldr(r7, Address(r21, r8));                 //	ldr	x7, [x21, x8]
    __ ldrw(r17, Address(r3, r3));                //	ldr	w17, [x3, x3]
    __ ldrb(r20, Address(r10, r24));              //	ldrb	w20, [x10, x24]
    __ ldrh(r12, Address(r27, r8));               //	ldrh	w12, [x27, x8]
    __ ldrsb(r10, Address(r4, r10));              //	ldrsb	x10, [x4, x10]
    __ ldrsh(r5, Address(r12, r25));              //	ldrsh	x5, [x12, x25]
    __ ldrshw(r13, Address(r29, r30));            //	ldrsh	w13, [x29, x30]
    __ ldrsw(r12, Address(r4, r26));              //	ldrsw	x12, [x4, x26]
    __ ldrd(v6, Address(r16, r9));                //	ldr	d6, [x16, x9]
    __ ldrs(v25, Address(r1, r21));               //	ldr	s25, [x1, x21]
    __ strd(v16, Address(r13, r15));              //	str	d16, [x13, x15]
    __ strs(v17, Address(r2, r8));                //	str	s17, [x2, x8]

// base_plus_scaled_offset 
// LoadStoreOp
    __ str(r30, Address(r23, 12632));             //	str	x30, [x23, 12632]
    __ strw(r3, Address(r29, 6928));              //	str	w3, [x29, 6928]
    __ strb(r22, Address(r9, 1865));              //	strb	w22, [x9, 1865]
    __ strh(r21, Address(r7, 3382));              //	strh	w21, [x7, 3382]
    __ ldr(r3, Address(r18, 13744));              //	ldr	x3, [x18, 13744]
    __ ldrw(r9, Address(r0, 7372));               //	ldr	w9, [x0, 7372]
    __ ldrb(r13, Address(r1, 2001));              //	ldrb	w13, [x1, 2001]
    __ ldrh(r6, Address(r5, 3562));               //	ldrh	w6, [x5, 3562]
    __ ldrsb(r22, Address(r4, 1974));             //	ldrsb	x22, [x4, 1974]
    __ ldrsh(r25, Address(r17, 4056));            //	ldrsh	x25, [x17, 4056]
    __ ldrshw(r10, Address(r16, 3236));           //	ldrsh	w10, [x16, 3236]
    __ ldrsw(r17, Address(r21, 6316));            //	ldrsw	x17, [x21, 6316]
    __ ldrd(v30, Address(r12, 13664));            //	ldr	d30, [x12, 13664]
    __ ldrs(v18, Address(r27, 7756));             //	ldr	s18, [x27, 7756]
    __ strd(v26, Address(r26, 15016));            //	str	d26, [x26, 15016]
    __ strs(v10, Address(r0, 6180));              //	str	s10, [x0, 6180]

// pcrel 
// LoadStoreOp
    __ ldr(r16, __ pc());                         //	ldr	x16, .
    __ ldrw(r30, __ pc());                        //	ldr	w30, .

// LoadStoreOp
    __ prfm(Address(r1, 117));                    //	prfm	PLDL1KEEP, [x1, 117]

// LoadStoreOp
    __ prfm(__ pc());                             //	prfm	PLDL1KEEP, .

// LoadStoreOp
    __ prfm(Address(r2, r1));                     //	prfm	PLDL1KEEP, [x2, x1]

// LoadStoreOp
    __ prfm(Address(r1, 12768));                  //	prfm	PLDL1KEEP, [x1, 12768]

// AddSubCarryOp
    __ adcw(r24, r20, r1);                        //	adc	w24, w20, w1
    __ adcsw(r3, r27, r28);                       //	adcs	w3, w27, w28
    __ sbcw(r0, r12, r17);                        //	sbc	w0, w12, w17
    __ sbcsw(r14, r26, r7);                       //	sbcs	w14, w26, w7
    __ adc(r19, r0, r29);                         //	adc	x19, x0, x29
    __ adcs(r29, r24, r6);                        //	adcs	x29, x24, x6
    __ sbc(r28, r8, r23);                         //	sbc	x28, x8, x23
    __ sbcs(r1, r5, r29);                         //	sbcs	x1, x5, x29

// AddSubExtendedOp
    __ addw(r8, r27, r16, ext::uxtx, 3);          //	add	w8, w27, w16, uxtx #3
    __ addsw(r14, r20, r4, ext::sxth, 1);         //	adds	w14, w20, w4, sxth #1
    __ sub(r21, r27, r19, ext::sxth, 2);          //	sub	x21, x27, x19, sxth #2
    __ subsw(r18, r18, r15, ext::sxth, 3);        //	subs	w18, w18, w15, sxth #3
    __ add(r6, r2, r14, ext::uxtw, 2);            //	add	x6, x2, x14, uxtw #2
    __ adds(r1, r27, r11, ext::uxtb, 2);          //	adds	x1, x27, x11, uxtb #2
    __ sub(r25, r27, r1, ext::sxtb, 2);           //	sub	x25, x27, x1, sxtb #2
    __ subs(r23, r4, r9, ext::sxth, 2);           //	subs	x23, x4, x9, sxth #2

// ConditionalCompareOp
    __ ccmnw(r26, r23, 2u, Assembler::GE);        //	ccmn	w26, w23, #2, GE
    __ ccmpw(r28, r16, 15u, Assembler::LE);       //	ccmp	w28, w16, #15, LE
    __ ccmn(r19, r5, 6u, Assembler::GT);          //	ccmn	x19, x5, #6, GT
    __ ccmp(r19, r1, 9u, Assembler::LT);          //	ccmp	x19, x1, #9, LT

// ConditionalCompareImmedOp
    __ ccmnw(r22, 23, 12, Assembler::EQ);         //	ccmn	w22, #23, #12, EQ
    __ ccmpw(r1, 14, 2, Assembler::CC);           //	ccmp	w1, #14, #2, CC
    __ ccmn(r0, 2, 6, Assembler::HS);             //	ccmn	x0, #2, #6, HS
    __ ccmp(r23, 4, 10, Assembler::NE);           //	ccmp	x23, #4, #10, NE

// ConditionalSelectOp
    __ cselw(r25, r3, r30, Assembler::LO);        //	csel	w25, w3, w30, LO
    __ csincw(r2, r0, r6, Assembler::GT);         //	csinc	w2, w0, w6, GT
    __ csinvw(r17, r26, r11, Assembler::MI);      //	csinv	w17, w26, w11, MI
    __ csnegw(r13, r7, r2, Assembler::CS);        //	csneg	w13, w7, w2, CS
    __ csel(r17, r11, r7, Assembler::HS);         //	csel	x17, x11, x7, HS
    __ csinc(r14, r1, r19, Assembler::CS);        //	csinc	x14, x1, x19, CS
    __ csinv(r7, r6, r28, Assembler::LS);         //	csinv	x7, x6, x28, LS
    __ csneg(r14, r1, r4, Assembler::HI);         //	csneg	x14, x1, x4, HI

// TwoRegOp
    __ rbitw(r26, r21);                           //	rbit	w26, w21
    __ rev16w(r11, r2);                           //	rev16	w11, w2
    __ revw(r9, r20);                             //	rev	w9, w20
    __ clzw(r21, r25);                            //	clz	w21, w25
    __ clsw(r3, r17);                             //	cls	w3, w17
    __ rbit(r0, r6);                              //	rbit	x0, x6
    __ rev16(r24, r18);                           //	rev16	x24, x18
    __ rev32(r7, r30);                            //	rev32	x7, x30
    __ rev(r13, r4);                              //	rev	x13, x4
    __ clz(r29, r20);                             //	clz	x29, x20
    __ cls(r2, r10);                              //	cls	x2, x10

// ThreeRegOp
    __ udivw(r18, r28, r23);                      //	udiv	w18, w28, w23
    __ sdivw(r23, r14, r13);                      //	sdiv	w23, w14, w13
    __ lslvw(r5, r19, r29);                       //	lslv	w5, w19, w29
    __ lsrvw(r22, r24, r21);                      //	lsrv	w22, w24, w21
    __ asrvw(r29, r27, r2);                       //	asrv	w29, w27, w2
    __ rorvw(r11, r30, r5);                       //	rorv	w11, w30, w5
    __ udiv(r6, r9, r10);                         //	udiv	x6, x9, x10
    __ sdiv(r13, r7, r28);                        //	sdiv	x13, x7, x28
    __ lslv(r22, r1, r2);                         //	lslv	x22, x1, x2
    __ lsrv(r27, r23, r8);                        //	lsrv	x27, x23, x8
    __ asrv(r10, r30, r18);                       //	asrv	x10, x30, x18
    __ rorv(r30, r26, r12);                       //	rorv	x30, x26, x12

// FourRegMulOp
    __ maddw(r19, r10, r12, r13);                 //	madd	w19, w10, w12, w13
    __ msubw(r25, r27, r1, r22);                  //	msub	w25, w27, w1, w22
    __ madd(r27, r30, r30, r8);                   //	madd	x27, x30, x30, x8
    __ msub(r0, r12, r14, r16);                   //	msub	x0, x12, x14, x16
    __ smaddl(r23, r4, r2, r18);                  //	smaddl	x23, w4, w2, x18
    __ smsubl(r15, r12, r3, r22);                 //	smsubl	x15, w12, w3, x22
    __ umaddl(r3, r10, r25, r15);                 //	umaddl	x3, w10, w25, x15
    __ umsubl(r0, r7, r12, r22);                  //	umsubl	x0, w7, w12, x22

// ThreeRegFloatOp
    __ fmuls(v12, v3, v14);                       //	fmul	s12, s3, s14
    __ fdivs(v14, v12, v9);                       //	fdiv	s14, s12, s9
    __ fadds(v16, v29, v9);                       //	fadd	s16, s29, s9
    __ fsubs(v24, v13, v6);                       //	fsub	s24, s13, s6
    __ fmuls(v22, v24, v30);                      //	fmul	s22, s24, s30
    __ fmuld(v3, v12, v29);                       //	fmul	d3, d12, d29
    __ fdivd(v20, v2, v10);                       //	fdiv	d20, d2, d10
    __ faddd(v26, v5, v8);                        //	fadd	d26, d5, d8
    __ fsubd(v16, v25, v18);                      //	fsub	d16, d25, d18
    __ fmuld(v12, v24, v27);                      //	fmul	d12, d24, d27

// FourRegFloatOp
    __ fmadds(v14, v11, v28, v1);                 //	fmadd	s14, s11, s28, s1
    __ fmsubs(v8, v29, v8, v24);                  //	fmsub	s8, s29, s8, s24
    __ fnmadds(v24, v20, v28, v6);                //	fnmadd	s24, s20, s28, s6
    __ fnmadds(v24, v10, v18, v22);               //	fnmadd	s24, s10, s18, s22
    __ fmaddd(v19, v23, v21, v23);                //	fmadd	d19, d23, d21, d23
    __ fmsubd(v24, v11, v22, v1);                 //	fmsub	d24, d11, d22, d1
    __ fnmaddd(v10, v12, v25, v12);               //	fnmadd	d10, d12, d25, d12
    __ fnmaddd(v3, v17, v7, v4);                  //	fnmadd	d3, d17, d7, d4

// TwoRegFloatOp
    __ fmovs(v11, v18);                           //	fmov	s11, s18
    __ fabss(v12, v4);                            //	fabs	s12, s4
    __ fnegs(v9, v24);                            //	fneg	s9, s24
    __ fsqrts(v25, v26);                          //	fsqrt	s25, s26
    __ fcvts(v14, v19);                           //	fcvt	d14, s19
    __ fmovd(v16, v3);                            //	fmov	d16, d3
    __ fabsd(v11, v25);                           //	fabs	d11, d25
    __ fnegd(v4, v18);                            //	fneg	d4, d18
    __ fsqrtd(v7, v19);                           //	fsqrt	d7, d19
    __ fcvtd(v25, v15);                           //	fcvt	s25, d15

// FloatConvertOp
    __ fcvtzsw(r16, v1);                          //	fcvtzs	w16, s1
    __ fcvtzs(r18, v16);                          //	fcvtzs	x18, s16
    __ fcvtzdw(r18, v30);                         //	fcvtzs	w18, d30
    __ fcvtzd(r19, v9);                           //	fcvtzs	x19, d9
    __ scvtfws(v23, r29);                         //	scvtf	s23, w29
    __ scvtfs(v14, r28);                          //	scvtf	s14, x28
    __ scvtfwd(v29, r11);                         //	scvtf	d29, w11
    __ scvtfd(v12, r14);                          //	scvtf	d12, x14
    __ fmovs(r3, v28);                            //	fmov	w3, s28
    __ fmovd(r6, v12);                            //	fmov	x6, d12
    __ fmovs(v7, r0);                             //	fmov	s7, w0
    __ fmovd(v1, r3);                             //	fmov	d1, x3

// TwoRegFloatOp
    __ fcmps(v2, v23);                            //	fcmp	s2, s23
    __ fcmpd(v15, v1);                            //	fcmp	d15, d1
    __ fcmps(v27, 0.0);                           //	fcmp	s27, #0.0
    __ fcmpd(v17, 0.0);                           //	fcmp	d17, #0.0

/*
aarch64ops.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <.text>:
   0:	8b1ea6ad 	add	x13, x21, x30, lsl #41
   4:	cb56be06 	sub	x6, x16, x22, lsr #47
   8:	ab096664 	adds	x4, x19, x9, lsl #25
   c:	eb8116e0 	subs	x0, x23, x1, asr #5
  10:	0b003ec1 	add	w1, w22, w0, lsl #15
  14:	4b4d4b74 	sub	w20, w27, w13, lsr #18
  18:	2b1c0d86 	adds	w6, w12, w28, lsl #3
  1c:	6b0c5409 	subs	w9, w0, w12, lsl #21
  20:	8a1be356 	and	x22, x26, x27, lsl #56
  24:	aa55faf4 	orr	x20, x23, x21, lsr #62
  28:	ca4840a3 	eor	x3, x5, x8, lsr #16
  2c:	ea444580 	ands	x0, x12, x4, lsr #17
  30:	0a010680 	and	w0, w20, w1, lsl #1
  34:	2a8832dd 	orr	w29, w22, w8, asr #12
  38:	4a99139b 	eor	w27, w28, w25, asr #4
  3c:	6a175cca 	ands	w10, w6, w23, lsl #23
  40:	8a79aada 	bic	x26, x22, x25, lsr #42
  44:	aaa1a05b 	orn	x27, x2, x1, asr #40
  48:	ca7ac067 	eon	x7, x3, x26, lsr #48
  4c:	ea389e77 	bics	x23, x19, x24, lsl #39
  50:	0a2a5eda 	bic	w26, w22, w10, lsl #23
  54:	2ab81e95 	orn	w21, w20, w24, asr #7
  58:	4a746e87 	eon	w7, w20, w20, lsr #27
  5c:	6abe0111 	bics	w17, w8, w30, asr #0
  60:	1103321a 	add	w26, w16, #0xcc
  64:	31098f71 	adds	w17, w27, #0x263
  68:	51065573 	sub	w19, w11, #0x195
  6c:	710b4db4 	subs	w20, w13, #0x2d3
  70:	9109d27b 	add	x27, x19, #0x274
  74:	b10d6a2b 	adds	x11, x17, #0x35a
  78:	d1049ce1 	sub	x1, x7, #0x127
  7c:	f109f7b2 	subs	x18, x29, #0x27d
  80:	12125014 	and	w20, w0, #0xffffc007
  84:	3202c76e 	orr	w14, w27, #0xc0c0c0c0
  88:	520d6ace 	eor	w14, w22, #0xfff83fff
  8c:	721f6f70 	ands	w16, w27, #0x1ffffffe
  90:	9278b6e9 	and	x9, x23, #0x3fffffffffff00
  94:	b26aacc5 	orr	x5, x6, #0xffffffffffc00003
  98:	d2651125 	eor	x5, x9, #0xf8000000
  9c:	f2434aa4 	ands	x4, x21, #0xe00000000000ffff
  a0:	14000000 	b	a0 <.text+0xa0>
  a4:	94000000 	bl	a4 <.text+0xa4>
  a8:	3400001b 	cbz	w27, a8 <.text+0xa8>
  ac:	35000007 	cbnz	w7, ac <.text+0xac>
  b0:	b4000019 	cbz	x25, b0 <.text+0xb0>
  b4:	b500000c 	cbnz	x12, b4 <.text+0xb4>
  b8:	10000017 	adr	x23, b8 <.text+0xb8>
  bc:	90000013 	adrp	x19, 0 <.text>
  c0:	36080014 	tbz	w20, #1, c0 <.text+0xc0>
  c4:	37600017 	tbnz	w23, #12, c4 <.text+0xc4>
  c8:	128c2eac 	movn	w12, #0x6175
  cc:	52a904c0 	movz	w0, #0x4826, lsl #16
  d0:	72811404 	movk	w4, #0x8a0
  d4:	92ed2f21 	movn	x1, #0x6979, lsl #48
  d8:	d2c8a1a2 	movz	x2, #0x450d, lsl #32
  dc:	f2acd9c4 	movk	x4, #0x66ce, lsl #16
  e0:	93477067 	sbfx	x7, x3, #7, #22
  e4:	33110703 	bfi	w3, w24, #15, #2
  e8:	53107b6a 	ubfx	w10, w27, #16, #15
  ec:	935d1391 	sbfiz	x17, x28, #35, #5
  f0:	b3564af2 	bfi	x18, x23, #42, #19
  f4:	d3453c8f 	ubfx	x15, x4, #5, #11
  f8:	13834a04 	extr	w4, w16, w3, #18
  fc:	93d45e56 	extr	x22, x18, x20, #23
 100:	54000000 	b.eq	100 <.text+0x100>
 104:	54000001 	b.ne	104 <.text+0x104>
 108:	54000002 	b.cs	108 <.text+0x108>
 10c:	54000002 	b.cs	10c <.text+0x10c>
 110:	54000003 	b.cc	110 <.text+0x110>
 114:	54000003 	b.cc	114 <.text+0x114>
 118:	54000004 	b.mi	118 <.text+0x118>
 11c:	54000005 	b.pl	11c <.text+0x11c>
 120:	54000006 	b.vs	120 <.text+0x120>
 124:	54000007 	b.vc	124 <.text+0x124>
 128:	54000008 	b.hi	128 <.text+0x128>
 12c:	54000009 	b.ls	12c <.text+0x12c>
 130:	5400000a 	b.ge	130 <.text+0x130>
 134:	5400000b 	b.lt	134 <.text+0x134>
 138:	5400000c 	b.gt	138 <.text+0x138>
 13c:	5400000d 	b.le	13c <.text+0x13c>
 140:	5400000e 	b.al	140 <.text+0x140>
 144:	5400000f 	b.nv	144 <.text+0x144>
 148:	d4077ec1 	svc	#0x3bf6
 14c:	d409ba82 	hvc	#0x4dd4
 150:	d4021d03 	smc	#0x10e8
 154:	d42ba700 	brk	#0x5d38
 158:	d4438340 	hlt	#0x1c1a
 15c:	d503201f 	nop
 160:	d69f03e0 	eret
 164:	d6bf03e0 	drps
 168:	d5033fdf 	isb
 16c:	d503379f 	dsb	nsh
 170:	d5033bbf 	dmb	ish
 174:	d61f0280 	br	x20
 178:	d63f02a0 	blr	x21
 17c:	c8197d34 	stxr	w25, x20, [x9]
 180:	c80eff0c 	stlxr	w14, x12, [x24]
 184:	c85f7c1d 	ldxr	x29, [x0]
 188:	c85ffc27 	ldaxr	x7, [x1]
 18c:	c89fffab 	stlr	x11, [x29]
 190:	c8dffe5a 	ldar	x26, [x18]
 194:	881c7dc7 	stxr	w28, w7, [x14]
 198:	880eff44 	stlxr	w14, w4, [x26]
 19c:	885f7ebc 	ldxr	w28, [x21]
 1a0:	885fff73 	ldaxr	w19, [x27]
 1a4:	889ffcec 	stlr	w12, [x7]
 1a8:	88dffcdb 	ldar	w27, [x6]
 1ac:	48027e38 	stxrh	w2, w24, [x17]
 1b0:	4808fee0 	stlxrh	w8, w0, [x23]
 1b4:	485f7e4f 	ldxrh	w15, [x18]
 1b8:	485ffc87 	ldaxrh	w7, [x4]
 1bc:	489ffc69 	stlrh	w9, [x3]
 1c0:	48dffdef 	ldarh	w15, [x15]
 1c4:	08017e15 	stxrb	w1, w21, [x16]
 1c8:	080afcf6 	stlxrb	w10, w22, [x7]
 1cc:	085f7fd2 	ldxrb	w18, [x30]
 1d0:	085ffcd9 	ldaxrb	w25, [x6]
 1d4:	089ffda9 	stlrb	w9, [x13]
 1d8:	08dffe56 	ldarb	w22, [x18]
 1dc:	c87f2252 	ldxp	x18, x8, [x18]
 1e0:	c87fa8b7 	ldaxp	x23, x10, [x5]
 1e4:	c8302484 	stxp	w16, x4, x9, [x4]
 1e8:	c828c8d2 	stlxp	w8, x18, x18, [x6]
 1ec:	887f0670 	ldxp	w16, w1, [x19]
 1f0:	887fde9a 	ldaxp	w26, w23, [x20]
 1f4:	883376b5 	stxp	w19, w21, w29, [x21]
 1f8:	882d83b7 	stlxp	w13, w23, w0, [x29]
 1fc:	f807b219 	str	x25, [x16,#123]
 200:	b80261fc 	str	w28, [x15,#38]
 204:	381e8284 	strb	w4, [x20,#-24]
 208:	781e012f 	strh	w15, [x9,#-32]
 20c:	f85271b8 	ldr	x24, [x13,#-217]
 210:	b859c219 	ldr	w25, [x16,#-100]
 214:	385ec300 	ldrb	w0, [x24,#-20]
 218:	785c7282 	ldrh	w2, [x20,#-57]
 21c:	389f9259 	ldrsb	x25, [x18,#-7]
 220:	789e33be 	ldrsh	x30, [x29,#-29]
 224:	78dc6101 	ldrsh	w1, [x8,#-58]
 228:	b898a3d1 	ldrsw	x17, [x30,#-118]
 22c:	fc517007 	ldr	d7, [x0,#-233]
 230:	bc5e30f9 	ldr	s25, [x7,#-29]
 234:	fc0712f5 	str	d21, [x23,#113]
 238:	bc02507b 	str	s27, [x3,#37]
 23c:	f81dbd37 	str	x23, [x9,#-37]!
 240:	b81b2d19 	str	w25, [x8,#-78]!
 244:	38002e96 	strb	w22, [x20,#2]!
 248:	781e7f39 	strh	w25, [x25,#-25]!
 24c:	f85c7ef6 	ldr	x22, [x23,#-57]!
 250:	b8401e3b 	ldr	w27, [x17,#1]!
 254:	3840dd5b 	ldrb	w27, [x10,#13]!
 258:	785cbfdc 	ldrh	w28, [x30,#-53]!
 25c:	389e8f3a 	ldrsb	x26, [x25,#-24]!
 260:	789d0e90 	ldrsh	x16, [x20,#-48]!
 264:	78dc7e50 	ldrsh	w16, [x18,#-57]!
 268:	b89dedcb 	ldrsw	x11, [x14,#-34]!
 26c:	fc44aea3 	ldr	d3, [x21,#74]!
 270:	bc5cdec4 	ldr	s4, [x22,#-51]!
 274:	fc1afc83 	str	d3, [x4,#-81]!
 278:	bc01ddad 	str	s13, [x13,#29]!
 27c:	f810b7b3 	str	x19, [x29],#-245
 280:	b81e34bc 	str	w28, [x5],#-29
 284:	381ea634 	strb	w20, [x17],#-22
 288:	781fe60f 	strh	w15, [x16],#-2
 28c:	f858c71b 	ldr	x27, [x24],#-116
 290:	b85bb62b 	ldr	w11, [x17],#-69
 294:	385ef770 	ldrb	w16, [x27],#-17
 298:	784094ba 	ldrh	w26, [x5],#9
 29c:	38809425 	ldrsb	x5, [x1],#9
 2a0:	7880f7a9 	ldrsh	x9, [x29],#15
 2a4:	78dc6556 	ldrsh	w22, [x10],#-58
 2a8:	b899759a 	ldrsw	x26, [x12],#-105
 2ac:	fc454762 	ldr	d2, [x27],#84
 2b0:	bc5a76c2 	ldr	s2, [x22],#-89
 2b4:	fc1354cf 	str	d15, [x6],#-203
 2b8:	bc1805b5 	str	s21, [x13],#-128
 2bc:	f8376b02 	str	x2, [x24,x23]
 2c0:	b8256b53 	str	w19, [x26,x5]
 2c4:	38256a7e 	strb	w30, [x19,x5]
 2c8:	78396a74 	strh	w20, [x19,x25]
 2cc:	f8686aa7 	ldr	x7, [x21,x8]
 2d0:	b8636871 	ldr	w17, [x3,x3]
 2d4:	38786954 	ldrb	w20, [x10,x24]
 2d8:	78686b6c 	ldrh	w12, [x27,x8]
 2dc:	38aa688a 	ldrsb	x10, [x4,x10]
 2e0:	78b96985 	ldrsh	x5, [x12,x25]
 2e4:	78fe6bad 	ldrsh	w13, [x29,x30]
 2e8:	b8ba688c 	ldrsw	x12, [x4,x26]
 2ec:	fc696a06 	ldr	d6, [x16,x9]
 2f0:	bc756839 	ldr	s25, [x1,x21]
 2f4:	fc2f69b0 	str	d16, [x13,x15]
 2f8:	bc286851 	str	s17, [x2,x8]
 2fc:	f918aefe 	str	x30, [x23,#12632]
 300:	b91b13a3 	str	w3, [x29,#6928]
 304:	391d2536 	strb	w22, [x9,#1865]
 308:	791a6cf5 	strh	w21, [x7,#3382]
 30c:	f95ada43 	ldr	x3, [x18,#13744]
 310:	b95ccc09 	ldr	w9, [x0,#7372]
 314:	395f442d 	ldrb	w13, [x1,#2001]
 318:	795bd4a6 	ldrh	w6, [x5,#3562]
 31c:	399ed896 	ldrsb	x22, [x4,#1974]
 320:	799fb239 	ldrsh	x25, [x17,#4056]
 324:	79d94a0a 	ldrsh	w10, [x16,#3236]
 328:	b998aeb1 	ldrsw	x17, [x21,#6316]
 32c:	fd5ab19e 	ldr	d30, [x12,#13664]
 330:	bd5e4f72 	ldr	s18, [x27,#7756]
 334:	fd1d575a 	str	d26, [x26,#15016]
 338:	bd18240a 	str	s10, [x0,#6180]
 33c:	58000010 	ldr	x16, 33c <.text+0x33c>
 340:	1800001e 	ldr	w30, 340 <.text+0x340>
 344:	f8875020 	prfm	pldl1keep, [x1,#117]
 348:	d8000000 	prfm	pldl1keep, 348 <.text+0x348>
 34c:	f8a16840 	prfm	pldl1keep, [x2,x1]
 350:	f998f020 	prfm	pldl1keep, [x1,#12768]
 354:	1a010298 	adc	w24, w20, w1
 358:	3a1c0363 	adcs	w3, w27, w28
 35c:	5a110180 	sbc	w0, w12, w17
 360:	7a07034e 	sbcs	w14, w26, w7
 364:	9a1d0013 	adc	x19, x0, x29
 368:	ba06031d 	adcs	x29, x24, x6
 36c:	da17011c 	sbc	x28, x8, x23
 370:	fa1d00a1 	sbcs	x1, x5, x29
 374:	0b306f68 	add	w8, w27, w16, uxtx #3
 378:	2b24a68e 	adds	w14, w20, w4, sxth #1
 37c:	cb33ab75 	sub	x21, x27, w19, sxth #2
 380:	6b2fae52 	subs	w18, w18, w15, sxth #3
 384:	8b2e4846 	add	x6, x2, w14, uxtw #2
 388:	ab2b0b61 	adds	x1, x27, w11, uxtb #2
 38c:	cb218b79 	sub	x25, x27, w1, sxtb #2
 390:	eb29a897 	subs	x23, x4, w9, sxth #2
 394:	3a57a342 	ccmn	w26, w23, #0x2, ge
 398:	7a50d38f 	ccmp	w28, w16, #0xf, le
 39c:	ba45c266 	ccmn	x19, x5, #0x6, gt
 3a0:	fa41b269 	ccmp	x19, x1, #0x9, lt
 3a4:	3a570acc 	ccmn	w22, #0x17, #0xc, eq
 3a8:	7a4e3822 	ccmp	w1, #0xe, #0x2, cc
 3ac:	ba422806 	ccmn	x0, #0x2, #0x6, cs
 3b0:	fa441aea 	ccmp	x23, #0x4, #0xa, ne
 3b4:	1a9e3079 	csel	w25, w3, w30, cc
 3b8:	1a86c402 	csinc	w2, w0, w6, gt
 3bc:	5a8b4351 	csinv	w17, w26, w11, mi
 3c0:	5a8224ed 	csneg	w13, w7, w2, cs
 3c4:	9a872171 	csel	x17, x11, x7, cs
 3c8:	9a93242e 	csinc	x14, x1, x19, cs
 3cc:	da9c90c7 	csinv	x7, x6, x28, ls
 3d0:	da84842e 	csneg	x14, x1, x4, hi
 3d4:	5ac002ba 	rbit	w26, w21
 3d8:	5ac0044b 	rev16	w11, w2
 3dc:	5ac00a89 	rev	w9, w20
 3e0:	5ac01335 	clz	w21, w25
 3e4:	5ac01623 	cls	w3, w17
 3e8:	dac000c0 	rbit	x0, x6
 3ec:	dac00658 	rev16	x24, x18
 3f0:	dac00bc7 	rev32	x7, x30
 3f4:	dac00c8d 	rev	x13, x4
 3f8:	dac0129d 	clz	x29, x20
 3fc:	dac01542 	cls	x2, x10
 400:	1ad70b92 	udiv	w18, w28, w23
 404:	1acd0dd7 	sdiv	w23, w14, w13
 408:	1add2265 	lsl	w5, w19, w29
 40c:	1ad52716 	lsr	w22, w24, w21
 410:	1ac22b7d 	asr	w29, w27, w2
 414:	1ac52fcb 	ror	w11, w30, w5
 418:	9aca0926 	udiv	x6, x9, x10
 41c:	9adc0ced 	sdiv	x13, x7, x28
 420:	9ac22036 	lsl	x22, x1, x2
 424:	9ac826fb 	lsr	x27, x23, x8
 428:	9ad22bca 	asr	x10, x30, x18
 42c:	9acc2f5e 	ror	x30, x26, x12
 430:	1b0c3553 	madd	w19, w10, w12, w13
 434:	1b01db79 	msub	w25, w27, w1, w22
 438:	9b1e23db 	madd	x27, x30, x30, x8
 43c:	9b0ec180 	msub	x0, x12, x14, x16
 440:	9b224897 	smaddl	x23, w4, w2, x18
 444:	9b23d98f 	smsubl	x15, w12, w3, x22
 448:	9bb93d43 	umaddl	x3, w10, w25, x15
 44c:	9bacd8e0 	umsubl	x0, w7, w12, x22
 450:	1e2e086c 	fmul	s12, s3, s14
 454:	1e29198e 	fdiv	s14, s12, s9
 458:	1e292bb0 	fadd	s16, s29, s9
 45c:	1e2639b8 	fsub	s24, s13, s6
 460:	1e3e0b16 	fmul	s22, s24, s30
 464:	1e7d0983 	fmul	d3, d12, d29
 468:	1e6a1854 	fdiv	d20, d2, d10
 46c:	1e6828ba 	fadd	d26, d5, d8
 470:	1e723b30 	fsub	d16, d25, d18
 474:	1e7b0b0c 	fmul	d12, d24, d27
 478:	1f1c056e 	fmadd	s14, s11, s28, s1
 47c:	1f08e3a8 	fmsub	s8, s29, s8, s24
 480:	1f3c1a98 	fnmadd	s24, s20, s28, s6
 484:	1f325958 	fnmadd	s24, s10, s18, s22
 488:	1f555ef3 	fmadd	d19, d23, d21, d23
 48c:	1f568578 	fmsub	d24, d11, d22, d1
 490:	1f79318a 	fnmadd	d10, d12, d25, d12
 494:	1f671223 	fnmadd	d3, d17, d7, d4
 498:	1e20424b 	fmov	s11, s18
 49c:	1e20c08c 	fabs	s12, s4
 4a0:	1e214309 	fneg	s9, s24
 4a4:	1e21c359 	fsqrt	s25, s26
 4a8:	1e22c26e 	fcvt	d14, s19
 4ac:	1e604070 	fmov	d16, d3
 4b0:	1e60c32b 	fabs	d11, d25
 4b4:	1e614244 	fneg	d4, d18
 4b8:	1e61c267 	fsqrt	d7, d19
 4bc:	1e6241f9 	fcvt	s25, d15
 4c0:	1e380030 	fcvtzs	w16, s1
 4c4:	9e380212 	fcvtzs	x18, s16
 4c8:	1e7803d2 	fcvtzs	w18, d30
 4cc:	9e780133 	fcvtzs	x19, d9
 4d0:	1e2203b7 	scvtf	s23, w29
 4d4:	9e22038e 	scvtf	s14, x28
 4d8:	1e62017d 	scvtf	d29, w11
 4dc:	9e6201cc 	scvtf	d12, x14
 4e0:	1e260383 	fmov	w3, s28
 4e4:	9e660186 	fmov	x6, d12
 4e8:	1e270007 	fmov	s7, w0
 4ec:	9e670061 	fmov	d1, x3
 4f0:	1e372040 	fcmp	s2, s23
 4f4:	1e6121e0 	fcmp	d15, d1
 4f8:	1e202368 	fcmp	s27, #0.0
 4fc:	1e602228 	fcmp	d17, #0.0
 */

  static const unsigned int insns[] =
  {
    0x8b1ea6ad,     0xcb56be06,     0xab096664,     0xeb8116e0,
    0x0b003ec1,     0x4b4d4b74,     0x2b1c0d86,     0x6b0c5409,
    0x8a1be356,     0xaa55faf4,     0xca4840a3,     0xea444580,
    0x0a010680,     0x2a8832dd,     0x4a99139b,     0x6a175cca,
    0x8a79aada,     0xaaa1a05b,     0xca7ac067,     0xea389e77,
    0x0a2a5eda,     0x2ab81e95,     0x4a746e87,     0x6abe0111,
    0x1103321a,     0x31098f71,     0x51065573,     0x710b4db4,
    0x9109d27b,     0xb10d6a2b,     0xd1049ce1,     0xf109f7b2,
    0x12125014,     0x3202c76e,     0x520d6ace,     0x721f6f70,
    0x9278b6e9,     0xb26aacc5,     0xd2651125,     0xf2434aa4,
    0x14000000,     0x94000000,     0x3400001b,     0x35000007,
    0xb4000019,     0xb500000c,     0x10000017,     0x90000013,
    0x36080014,     0x37600017,     0x128c2eac,     0x52a904c0,
    0x72811404,     0x92ed2f21,     0xd2c8a1a2,     0xf2acd9c4,
    0x93477067,     0x33110703,     0x53107b6a,     0x935d1391,
    0xb3564af2,     0xd3453c8f,     0x13834a04,     0x93d45e56,
    0x54000000,     0x54000001,     0x54000002,     0x54000002,
    0x54000003,     0x54000003,     0x54000004,     0x54000005,
    0x54000006,     0x54000007,     0x54000008,     0x54000009,
    0x5400000a,     0x5400000b,     0x5400000c,     0x5400000d,
    0x5400000e,     0x5400000f,     0xd4077ec1,     0xd409ba82,
    0xd4021d03,     0xd42ba700,     0xd4438340,     0xd503201f,
    0xd69f03e0,     0xd6bf03e0,     0xd5033fdf,     0xd503379f,
    0xd5033bbf,     0xd61f0280,     0xd63f02a0,     0xc8197d34,
    0xc80eff0c,     0xc85f7c1d,     0xc85ffc27,     0xc89fffab,
    0xc8dffe5a,     0x881c7dc7,     0x880eff44,     0x885f7ebc,
    0x885fff73,     0x889ffcec,     0x88dffcdb,     0x48027e38,
    0x4808fee0,     0x485f7e4f,     0x485ffc87,     0x489ffc69,
    0x48dffdef,     0x08017e15,     0x080afcf6,     0x085f7fd2,
    0x085ffcd9,     0x089ffda9,     0x08dffe56,     0xc87f2252,
    0xc87fa8b7,     0xc8302484,     0xc828c8d2,     0x887f0670,
    0x887fde9a,     0x883376b5,     0x882d83b7,     0xf807b219,
    0xb80261fc,     0x381e8284,     0x781e012f,     0xf85271b8,
    0xb859c219,     0x385ec300,     0x785c7282,     0x389f9259,
    0x789e33be,     0x78dc6101,     0xb898a3d1,     0xfc517007,
    0xbc5e30f9,     0xfc0712f5,     0xbc02507b,     0xf81dbd37,
    0xb81b2d19,     0x38002e96,     0x781e7f39,     0xf85c7ef6,
    0xb8401e3b,     0x3840dd5b,     0x785cbfdc,     0x389e8f3a,
    0x789d0e90,     0x78dc7e50,     0xb89dedcb,     0xfc44aea3,
    0xbc5cdec4,     0xfc1afc83,     0xbc01ddad,     0xf810b7b3,
    0xb81e34bc,     0x381ea634,     0x781fe60f,     0xf858c71b,
    0xb85bb62b,     0x385ef770,     0x784094ba,     0x38809425,
    0x7880f7a9,     0x78dc6556,     0xb899759a,     0xfc454762,
    0xbc5a76c2,     0xfc1354cf,     0xbc1805b5,     0xf8376b02,
    0xb8256b53,     0x38256a7e,     0x78396a74,     0xf8686aa7,
    0xb8636871,     0x38786954,     0x78686b6c,     0x38aa688a,
    0x78b96985,     0x78fe6bad,     0xb8ba688c,     0xfc696a06,
    0xbc756839,     0xfc2f69b0,     0xbc286851,     0xf918aefe,
    0xb91b13a3,     0x391d2536,     0x791a6cf5,     0xf95ada43,
    0xb95ccc09,     0x395f442d,     0x795bd4a6,     0x399ed896,
    0x799fb239,     0x79d94a0a,     0xb998aeb1,     0xfd5ab19e,
    0xbd5e4f72,     0xfd1d575a,     0xbd18240a,     0x58000010,
    0x1800001e,     0xf8875020,     0xd8000000,     0xf8a16840,
    0xf998f020,     0x1a010298,     0x3a1c0363,     0x5a110180,
    0x7a07034e,     0x9a1d0013,     0xba06031d,     0xda17011c,
    0xfa1d00a1,     0x0b306f68,     0x2b24a68e,     0xcb33ab75,
    0x6b2fae52,     0x8b2e4846,     0xab2b0b61,     0xcb218b79,
    0xeb29a897,     0x3a57a342,     0x7a50d38f,     0xba45c266,
    0xfa41b269,     0x3a570acc,     0x7a4e3822,     0xba422806,
    0xfa441aea,     0x1a9e3079,     0x1a86c402,     0x5a8b4351,
    0x5a8224ed,     0x9a872171,     0x9a93242e,     0xda9c90c7,
    0xda84842e,     0x5ac002ba,     0x5ac0044b,     0x5ac00a89,
    0x5ac01335,     0x5ac01623,     0xdac000c0,     0xdac00658,
    0xdac00bc7,     0xdac00c8d,     0xdac0129d,     0xdac01542,
    0x1ad70b92,     0x1acd0dd7,     0x1add2265,     0x1ad52716,
    0x1ac22b7d,     0x1ac52fcb,     0x9aca0926,     0x9adc0ced,
    0x9ac22036,     0x9ac826fb,     0x9ad22bca,     0x9acc2f5e,
    0x1b0c3553,     0x1b01db79,     0x9b1e23db,     0x9b0ec180,
    0x9b224897,     0x9b23d98f,     0x9bb93d43,     0x9bacd8e0,
    0x1e2e086c,     0x1e29198e,     0x1e292bb0,     0x1e2639b8,
    0x1e3e0b16,     0x1e7d0983,     0x1e6a1854,     0x1e6828ba,
    0x1e723b30,     0x1e7b0b0c,     0x1f1c056e,     0x1f08e3a8,
    0x1f3c1a98,     0x1f325958,     0x1f555ef3,     0x1f568578,
    0x1f79318a,     0x1f671223,     0x1e20424b,     0x1e20c08c,
    0x1e214309,     0x1e21c359,     0x1e22c26e,     0x1e604070,
    0x1e60c32b,     0x1e614244,     0x1e61c267,     0x1e6241f9,
    0x1e380030,     0x9e380212,     0x1e7803d2,     0x9e780133,
    0x1e2203b7,     0x9e22038e,     0x1e62017d,     0x9e6201cc,
    0x1e260383,     0x9e660186,     0x1e270007,     0x9e670061,
    0x1e372040,     0x1e6121e0,     0x1e202368,     0x1e602228,

  };
// END  Generated code -- do not edit

  {
    bool ok = true;
    unsigned int *insns1 = (unsigned int *)entry;
    for (unsigned int i = 0; i < sizeof insns / sizeof insns[0]; i++) {
      if (insns[i] != insns1[i]) {
	ok = false;
	printf("Ours:\n");
	Disassembler::decode((address)&insns1[i], (address)&insns1[i+1]);
	printf("Theirs:\n");
	Disassembler::decode((address)&insns[i], (address)&insns[i+1]);
	printf("\n");
      }
    }
    assert(ok, "Assembler smoke test failed");
  }
#endif // ASSERT

#ifdef PRODUCT
#define BLOCK_COMMENT(str) /* nothing */
#else
#define BLOCK_COMMENT(str) __ block_comment(str)
#endif

#define BIND(label) bind(label); BLOCK_COMMENT(#label ":")

  {
    Label l, loop;
    address a = __ pc();
    __ movz(r0, 0);
    __ BIND(loop);
    __ subs(sp, r0, 10);
    __ br(Assembler::NE, l);
    __ add(r0, r0, 1u);
    __ br(Assembler::AL, loop);
    __ BIND(l);
    Disassembler::decode(a, __ pc());
  }
}


#define gas_assert(ARG1) assert(ARG1, #ARG1)

// ------------- Stolen from binutils begin -------------------------------------

/* Build the accepted values for immediate logical SIMD instructions.
 *
 * The valid encodings of the immediate value are:
 *   opc<0> j:jjjjj  i:iii:ii  SIMD size  R             S
 *   1      ssssss   rrrrrr       64      UInt(rrrrrr)  UInt(ssssss)
 *   0      0sssss   0rrrrr       32      UInt(rrrrr)   UInt(sssss)
 *   0      10ssss   00rrrr       16      UInt(rrrr)    UInt(ssss)
 *   0      110sss   000rrr       8       UInt(rrr)     UInt(sss)
 *   0      1110ss   0000rr       4       UInt(rr)      UInt(ss)
 *   0      11110s   00000r       2       UInt(r)       UInt(s)
 *   other combinations                   UNPREDICTABLE
 *
 * Let's call E the SIMD size.
 *
 * The immediate value is: S+1 bits '1' rotated to the right by R.
 *
 * The total of valid encodings is 64^2 + 32^2 + ... + 2^2 = 5460.
 *
 * This means we have the following number of distinct values:
 *   - for S = E - 1, all values of R generate a word full of '1'
 *      so we have 2 + 4 + ... + 64 = 126 ways of encoding 0xf...f
 *   - for S != E - 1, all value are obviously distinct
 *      so we have #{ for all E: (E - 1) * R (where R = E) } values
 *        = 64*63 + 32*31 + ... + 2*1 = 5334
 *   - it is obvious that for two different values of E, if S != E - 1
 *      then we can't generate the same value.
 * So the total number of distinct values is 5334 + 1 = 5335 (out of
 * a total of 5460 valid encodings).
 */
#define TOTAL_IMM_NB  5334

typedef struct {
  uint64_t imm;
  uint32_t encoding;
} simd_imm_encoding_v2;

static simd_imm_encoding_v2 simd_immediates_v2[TOTAL_IMM_NB];

static int
simd_imm_encoding_cmp_v2(const void *i1, const void *i2)
{
  const simd_imm_encoding_v2 *imm1 = (const simd_imm_encoding_v2 *)i1;
  const simd_imm_encoding_v2 *imm2 = (const simd_imm_encoding_v2 *)i2;

  if (imm1->imm < imm2->imm)
    return -1;
  if (imm1->imm > imm2->imm)
    return +1;
  return 0;
}

/* immediate bitfield encoding
 * imm13<12> imm13<5:0> imm13<11:6> SIMD size R      S
 * 1         ssssss     rrrrrr      64        rrrrrr ssssss
 * 0         0sssss     0rrrrr      32        rrrrr  sssss
 * 0         10ssss     00rrrr      16        rrrr   ssss
 * 0         110sss     000rrr      8         rrr    sss
 * 0         1110ss     0000rr      4         rr     ss
 * 0         11110s     00000r      2         r      s
 */
static inline int encode_immediate_bitfield(int is64, uint32_t s, uint32_t r)
{
  return (is64 << 12) | (r << 6) | s;
}

static void
build_immediate_table_v2(void) __attribute__ ((constructor));

static void
build_immediate_table_v2(void)
{
  uint32_t log_e, e, s, r, s_mask;
  uint64_t mask, imm;
  int nb_imms;
  int is64;

  nb_imms = 0;
  for (log_e = 1; log_e <= 6; log_e++) {
    e = 1u << log_e;
    if (log_e == 6) {
      is64 = 1;
      mask = 0xffffffffffffffffull;
      s_mask = 0;
    } else {
      is64 = 0;
      mask = (1ull << e) - 1;
      /* log_e  s_mask
       *  1     ((1 << 4) - 1) << 2 = 111100
       *  2     ((1 << 3) - 1) << 3 = 111000
       *  3     ((1 << 2) - 1) << 4 = 110000
       *  4     ((1 << 1) - 1) << 5 = 100000
       *  5     ((1 << 0) - 1) << 6 = 000000
       */
      s_mask = ((1u << (5 - log_e)) - 1) << (log_e + 1);
    }
    for (s = 0; s < e - 1; s++) {
      for (r = 0; r < e; r++) {
        /* s+1 consecutive bits to 1 (s < 63) */
        imm = (1ull << (s + 1)) - 1;
        /* rotate right by r */
        if (r != 0)
          imm = (imm >> r) | ((imm << (e - r)) & mask);
        /* replicate the constant depending on SIMD size */
        switch (log_e) {
        case 1: imm = (imm <<  2) | imm;
        case 2: imm = (imm <<  4) | imm;
        case 3: imm = (imm <<  8) | imm;
        case 4: imm = (imm << 16) | imm;
        case 5: imm = (imm << 32) | imm;
        case 6:
          break;
        default:
          abort ();
        }
        simd_immediates_v2[nb_imms].imm = imm;
        simd_immediates_v2[nb_imms].encoding =
          encode_immediate_bitfield(is64, s | s_mask, r);
        nb_imms++;
      }
    }
  }
  gas_assert(nb_imms == TOTAL_IMM_NB);
  qsort(simd_immediates_v2, nb_imms,
        sizeof(simd_immediates_v2[0]), simd_imm_encoding_cmp_v2);
}

/* Create a valid encoding for imm.  Returns ffffffff since it's an invalid
   encoding.  */
uint32_t
asm_util::encode_immediate_v2(int is32, uint64_t imm)
{
  simd_imm_encoding_v2 imm_enc;
  const simd_imm_encoding_v2 *imm_encoding;

  if (is32) {
    /* Allow all zeros or all ones in top 32-bits, so that
       constant expressions like ~1 are permitted. */
    if (imm >> 32 != 0 && imm >> 32 != 0xffffffff)
      return 0xffffffff;
    /* Replicate the 32 lower bits to the 32 upper bits.  */
    imm &= 0xffffffff;
    imm |= imm << 32;
  }

  imm_enc.imm = imm;
  imm_encoding = (const simd_imm_encoding_v2 *)
    bsearch(&imm_enc, simd_immediates_v2, TOTAL_IMM_NB,
            sizeof(simd_immediates_v2[0]), simd_imm_encoding_cmp_v2);
  if (imm_encoding == NULL)
    return 0xffffffff;
  return imm_encoding->encoding;
}

// ------------- Stolen from binutils end -------------------------------------

Instruction_aarch64::~Instruction_aarch64() {
  assem->emit();
}

bool Assembler::operand_valid_for_logical_immdiate(int is32, uint64_t imm) {
  return encode_immediate_v2(is32, imm) != 0xffffffff;
}

void Assembler::br(Condition cc, Label &L) {
  if (L.is_bound()) {
    cond_branch(cc, target(L));
  } else {
    InstructionMark im(this);
    L.add_patch_at(code(), locator());
    cond_branch(cc, pc());
  }
}

void MacroAssembler::pd_patch_instruction(address branch, address target) {
  long offset = (target - branch) >> 2;
  Instruction_aarch64::spatch(branch, 23, 5, offset);
}

int AbstractAssembler::code_fill_byte() { Unimplemented(); }

// added to make this compile

REGISTER_DEFINITION(Register, noreg);

void MacroAssembler::call_VM_base(Register oop_result,
				  Register java_thread,
				  Register last_java_sp,
				  address  entry_point,
				  int      number_of_arguments,
				  bool     check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             bool check_exceptions) { Unimplemented(); }


void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             Register arg_3,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
			     Register last_java_sp,
			     address entry_point,
			     int number_of_arguments,
			     bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
			     bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::call_VM(Register oop_result,
                             Register last_java_sp,
                             address entry_point,
                             Register arg_1,
                             Register arg_2,
                             Register arg_3,
                             bool check_exceptions) { Unimplemented(); }

void MacroAssembler::check_and_handle_earlyret(Register java_thread) {Unimplemented(); }

void MacroAssembler::align(int modulus) { Unimplemented();}

void MacroAssembler::check_and_handle_popframe(Register java_thread) { Unimplemented(); }

RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
                                                      Register tmp,
                                                      int offset) { Unimplemented(); return RegisterOrConstant(r0); }

void MacroAssembler::verify_oop(Register reg, const char* s) { Unimplemented(); }

void MacroAssembler::stop(const char* msg) { Unimplemented(); }

void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) { Unimplemented(); }

void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) { Unimplemented(); }

void MacroAssembler::null_check(Register reg, int offset) { Unimplemented(); }

// routine to generate an x86 prolog for a stub function which
// bootstraps into the generated ARM code which directly follows the
// stub
//
// the argument encodes the number of general and fp registers
// passed by the caller and the callng convention (currently just
// the number of general registers and assumes C argument passing)

extern "C" {
int aarch64_stub_prolog_size();
void aarch64_stub_prolog();
void setup_arm_sim(void *sp, int calltype);
}

void MacroAssembler::c_stub_prolog(u_int64_t calltype)
{
  // the addresses for the x86 to ARM entry code we need to use
  address start = pc();
  // printf("start = %lx\n", start);
  int byteCount =  aarch64_stub_prolog_size();
  // printf("byteCount = %x\n", byteCount);
  int instructionCount = (byteCount + 3)/ 4;
  // printf("instructionCount = %x\n", instructionCount);
  for (int i = 0; i < instructionCount; i++) {
    nop();
  }

  memcpy(start, (void*)aarch64_stub_prolog, byteCount);

  // write the address of the setup routine and the call format at the
  // end of into the copied code
  u_int64_t *patch_end = (u_int64_t *)(start + byteCount);
  patch_end[-2] = (u_int64_t)setup_arm_sim;
  patch_end[-1] = calltype;
}
